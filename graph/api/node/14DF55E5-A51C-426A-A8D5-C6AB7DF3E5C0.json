{
  "id": "14DF55E5-A51C-426A-A8D5-C6AB7DF3E5C0",
  "title": "「The Rust Programming Language 日本語版」の読書記録",
  "raw": ":PROPERTIES:\n:ID:       14DF55E5-A51C-426A-A8D5-C6AB7DF3E5C0\n:ROAM_REFS: @TheRustP1-online\n:END:\n#+title: 「The Rust Programming Language 日本語版」の読書記録\n#+AUTHOR: takeokunn\n#+DATE: 2025-12-25T22:20:15+0900\n#+HUGO_BASE_DIR: ../../\n#+HUGO_CATEGORIES: literature\n#+HUGO_SECTION: posts/literature\n#+HUGO_TAGS: literature rust\n#+HUGO_DRAFT: false\n#+STARTUP: fold\n* 文献情報\n\n- 出典: [[https://doc.rust-jp.rs/book-ja/title-page.html][The Rust Programming Language 日本語版]]\n- 著者: Rust日本語ドキュメント翻訳プロジェクト\n- 参照日: 2025-12-25\n- 種別: オンライン書籍\n\n* 読む目的・背景\n\n社内でRustを使っているため、業務で必要な知識として勉強する必要があった。\n他言語で得た知識で知ったかぶりせず、Rust固有の概念を正確に理解したい。\n特に所有権・借用・ライフタイム・スマートポインタといった概念の本質を理解することを目標とした。\n\n* 重要ポイントと引用\n** 所有権（Ownership）\n\n#+begin_quote\nRustの各値は、所有者と呼ばれる変数と対応している。いかなる時も所有者は一つである。所有者がスコープから外れたら、値は破棄される。\n\n--- [[https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html][第4章 所有権を理解する]]\n#+end_quote\n\n所有権はRustのもっとも特徴的な機能であり、ガベージコレクタなしでメモリ安全性を保証する仕組みになっている。\nC/C++ではプログラマが手動でメモリを管理する必要があり、解放忘れ（メモリリーク）や二重解放といったバグが発生しやすかった。\n一方、JavaやPythonなどのGC言語では実行時のオーバーヘッドが発生する。\nRustは所有権システムによって、コンパイル時にメモリ管理の正しさを検証し、実行時コストなしで安全性を実現している。\n\n所有権には3つのルールがある。\n\n1. Rustの各値は所有者と呼ばれる変数をもつ\n2. いかなる時も所有者は1つだけ\n3. 所有者がスコープから外れると、値は破棄される（ =drop= が呼ばれる）。\n\n#+begin_src rust\nfn main() {\n    let s1 = String::from(\"hello\");  // s1が所有者\n    let s2 = s1;                      // 所有権がs2にムーブ\n    // println!(\"{}\", s1);            // エラー: s1は無効\n    println!(\"{}\", s2);               // OK: s2が所有者\n}\n#+end_src\n\nヒープに確保されるデータ（ =String= など）は代入時に所有権がムーブする。\nスタックに確保される固定サイズのデータ（整数など）は =Copy= トレイトを実装しており、コピーされる。\n\n** 借用（Borrowing）\n\n#+begin_quote\n関数の引数に参照を取ることを借用と呼びます。現実生活のように、誰かが何かを所有していたら、それを借りることができます。用が済んだら、返さなきゃいけないわけです。\n\n--- [[https://doc.rust-jp.rs/book-ja/ch04-02-references-and-borrowing.html][第4章 参照と借用]]\n#+end_quote\n\n借用は所有権をムーブせずにデータにアクセスする仕組みになっている。\n関数に値を渡すたびに所有権が移動すると、呼び出し元で値が使えなくなり不便になる。\n借用を使えば、所有権を保持したまま一時的にデータへのアクセスを許可できる。\n\n借用には2種類ある。\n不変参照（ =&T= ）は読み取り専用で、同時に複数存在できる。\n可変参照（ =&mut T= ）は書き込み可能だが、同時に1つしか存在できない。\n\nこの制約により、データ競合をコンパイル時に防止する。\n\n#+begin_src rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    // 不変参照: 複数OK\n    let r1 = &s;\n    let r2 = &s;\n    println!(\"{}, {}\", r1, r2);\n\n    // 可変参照: 1つだけ\n    let r3 = &mut s;\n    r3.push_str(\" world\");\n    println!(\"{}\", r3);\n}\n#+end_src\n\n重要なルールとして、不変参照が存在する間は可変参照を作成できない。\nこれはRustの「共有XOR可変」原則と呼ばれ、複数の読み取りか単一の書き込みのどちらかしか許可しない。\n\n** ライフタイム（Lifetime）\n\n#+begin_quote\nライフタイムの主な目的は、ダングリング参照を回避することです\n\n--- [[https://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html][第10章 ライフタイムで参照を検証する]]\n#+end_quote\n\nライフタイムは参照が有効な期間を表すアノテーションとなっている。\nRustコンパイラの借用チェッカーは、すべての参照がそのライフタイム内で有効であることを検証する。\n\nこれによりダングリング参照（無効なメモリを指す参照）をコンパイル時に防止する。\n\n多くの場合、ライフタイムは暗黙的に推論される（ライフタイム省略規則）。\nしかし、複数の参照を受け取って参照を返す関数では、コンパイラがどの入力参照と出力参照が関連しているかを判断できないため、明示的なライフタイムアノテーションが必要になる。\n\n#+begin_src rust\n// 'a はライフタイムパラメータ\n// 戻り値の参照は、x と y のうち短い方のライフタイムを持つ\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let s1 = String::from(\"long string\");\n    let result;\n    {\n        let s2 = String::from(\"short\");\n        result = longest(&s1, &s2);\n        println!(\"{}\", result);  // OK: s2がまだ有効\n    }\n    // println!(\"{}\", result);  // エラー: s2のライフタイムが終了\n}\n#+end_src\n\nライフタイムアノテーション ='a= は参照の実際の生存期間を変更しない。\n複数の参照間の関係をコンパイラに伝えるためのものとなっている。\n構造体が参照を保持する場合も、ライフタイムアノテーションが必要になる。\n\n** スマートポインタ（Smart Pointer）\n\n#+begin_quote\nスマートポインタは、ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造です\n\n--- [[https://doc.rust-jp.rs/book-ja/ch15-00-smart-pointers.html][第15章 スマートポインタ]]\n#+end_quote\n\nスマートポインタはポインタのように振る舞いつつ、メモリ管理などの追加機能をもつデータ構造となっている。\n通常の参照は単にデータを借用するだけだが、スマートポインタはデータを所有することが多い。\n\n代表的なスマートポインタには =Box<T>= 、 =Rc<T>= 、 =RefCell<T>= がある。\n\n=Box<T>= はヒープにデータを確保するもっともシンプルなスマートポインタとなっている。\n再帰的なデータ構造（リンクリストなど）やサイズが不明な型を扱う際に使用する。\n\n#+begin_src rust\n// 再帰的なデータ構造にはBoxが必要\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nfn main() {\n    let list = List::Cons(1,\n        Box::new(List::Cons(2,\n            Box::new(List::Nil))));\n}\n#+end_src\n\n=Rc<T>= （Reference Counting）は複数の所有者をもつデータを扱う。\n参照カウントにより、最後の所有者がスコープを抜けた時点でデータが破棄される。\n\nただしシングルスレッド専用であり、マルチスレッドでは =Arc<T>= を使用する。\n\n=RefCell<T>= は実行時に借用規則をチェックする「内部可変性」パターンを実現する。\nコンパイル時には不変でも、実行時に内部の値を変更できる。\n=Rc<RefCell<T>>= の組み合わせで、複数の所有者が可変データを共有できる。\n\n** 並行性（Concurrency）\n\n#+begin_quote\n所有権と型チェックを活用することで、多くの並行性エラーは、実行時エラーではなくコンパイル時エラーになります。Rustのこの方向性を恐れるな！並行性とニックネーム付けしました。\n\n--- [[https://doc.rust-jp.rs/book-ja/ch16-00-concurrency.html][第16章 恐れるな！並行性]]\n#+end_quote\n\nRustの所有権システムは並行プログラミングにおいても強力な安全性を提供する。\nデータ競合（複数のスレッドが同じメモリに同時にアクセスし、少なくとも1つが書き込みを行う状況）はコンパイル時に検出される。\n\nスレッド間でデータを共有するには =Send= トレイトと =Sync= トレイトが重要になる。\n=Send= はスレッド間で所有権を移動できることを示し、 =Sync= は複数スレッドからの参照が安全であることを示す。\n\nほとんどの型は自動的にこれらを実装するが、 =Rc<T>= は =Send= を実装しないため、スレッド間で共有するには =Arc<T>= （Atomic Reference Counting）を使用する。\n\n#+begin_src rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    // Arc: スレッド間で安全に共有\n    // Mutex: 排他的アクセスを保証\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n#+end_src\n\n=Mutex<T>= は排他制御を提供し、一度に1つのスレッドのみがデータにアクセスできることを保証する。\nロックの解放忘れはRAIIパターンにより自動的に処理される。\n\nまた、メッセージパッシングによるスレッド間通信には =std::sync::mpsc= チャネルを使用する。\n\n** パターンとマッチング（Pattern Matching）\n\n#+begin_quote\nパターンは、複雑であれ、単純であれ、Rustで型の構造に一致する特別な記法です。\n\n--- [[https://doc.rust-jp.rs/book-ja/ch18-00-patterns.html][第18章 パターンとマッチング]]\n#+end_quote\n\nパターンマッチングはRustの強力な制御フロー機能となっている。\n=match= 式はすべてのケースを網羅的にチェックし、漏れがあればコンパイルエラーになる。\n\nこれにより =null= や例外による実行時エラーを防ぐ。\n\nパターンは =match= 式だけでなく、さまざまな場所で使用できる。\n=if let= や =while let= 、 =for= ループ、関数引数、 =let= 文などが対象となる。\n構造体やenumの分解、参照のマッチング、ガード条件など、豊富なパターン記法がある。\n\n#+begin_src rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn process_message(msg: Message) {\n    match msg {\n        Message::Quit => println!(\"終了\"),\n        Message::Move { x, y } => println!(\"移動: ({}, {})\", x, y),\n        Message::Write(text) => println!(\"メッセージ: {}\", text),\n        Message::ChangeColor(r, g, b) => {\n            println!(\"色変更: RGB({}, {}, {})\", r, g, b)\n        }\n    }\n}\n\nfn main() {\n    // if let: 1つのパターンのみをマッチしたい場合\n    let some_value = Some(5);\n    if let Some(x) = some_value {\n        println!(\"値: {}\", x);\n    }\n\n    // ガード条件\n    let num = Some(4);\n    match num {\n        Some(x) if x < 5 => println!(\"5未満: {}\", x),\n        Some(x) => println!(\"5以上: {}\", x),\n        None => println!(\"なし\"),\n    }\n}\n#+end_src\n\nRustでは =Option<T>= と =Result<T, E>= 型を多用する。\nこれらのenumとパターンマッチングを組み合わせることで、null参照やエラー処理を型システムで安全に扱える。\n\n* 自分の考察・気づき\n\n他言語で「なんとなく動く」と思っていたメモリ管理が、Rustでは明示的に理解する必要がある。\nGCのある言語では意識しなかった所有権の概念が、C/C++のメモリ管理の問題を解決していることに気づいた。\n\n特にスタックとヒープの違いを意識する必要がある。\nスタックは固定サイズのデータを高速に確保・解放でき、ヒープは可変サイズのデータを扱えるが管理コストがかかる。\n\nRustではこの違いが所有権やムーブセマンティクスに直結しており、 =Copy= トレイトを実装する型（整数など）はスタックでコピーされ、 =String= などのヒープデータはムーブされる。\n\nコンパイラが「親切に」エラーを教えてくれる設計思想が印象的だった。「ゼロコスト抽象化」という概念、つまり安全性と性能の両立を実現している点も興味深い。\n\n* 関連する知識へのリンク\n\n- [[id:360860F2-3F77-4989-81DF-FF43B9F96FF7][社内読書会でThe Rust Programming Languageを読破した]]\n\n* 今後の活用案\n\nJSONパーサを自作してみる。\n",
  "backlinks": []
}