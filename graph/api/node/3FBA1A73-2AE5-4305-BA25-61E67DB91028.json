{
  "id": "3FBA1A73-2AE5-4305-BA25-61E67DB91028",
  "title": "Emacsを世界最速級で起動する方法",
  "raw": ":PROPERTIES:\n:ID:       3FBA1A73-2AE5-4305-BA25-61E67DB91028\n:mtime:    20231217115756\n:ctime:    20221217132815\n:END:\n#+TITLE: Emacsを世界最速級で起動する方法\n#+AUTHOR: takeokunn\n#+DESCRIPTION: description\n#+DATE: 2022-12-17T09:00:00+09:00\n#+HUGO_BASE_DIR: ../../\n#+HUGO_SECTION: posts/permanent\n#+HUGO_CATEGORIES: permanent\n#+HUGO_TAGS: emacs\n#+HUGO_DRAFT: false\n#+STARTUP: fold\n\n[[https://qiita.com/advent-calendar/2022/emacs][Emacs Advent Calendar 2022]] 19日目です。\n\n[[https://qiita.com/advent-calendar/2022/vim][Vim Advent Calendar 2022]] 3日目の [[https://qiita.com/delphinus/items/fb905e452b2de72f1a0f][爆速で起動する Neovim を作る]] に触発されて、「自分もEmacs版を書くぞ！」ということで書いていきます。\n\nなお、VimとEmacsの比較をし易くするためになるべく文章の構成を寄せて書くことをご了承ください。\n\n* 始めに\n\n「Emacsを高速に起動する」ということに対して、多くのEmacsユーザーは興味がありません。\n本来Emacsというのは常に起動し続けるものであり、必要に応じてEmacs Lispを適用し、テキストエディタをカスタマイズしていくものです。\n現に「Emacs, 起動、 高速化」と検索すると、「4000msを1000msにした」のような秒単位での高速化の記事ばかりみつかります。\n\nもしあなたが設定を変えずに手軽に高速に起動したい場合は ~emacs --daemon~ でdaemonを立ち上げ、 ~emacsclient~ でつなぐようにすればよいでしょう。\n私は他人のdotfilesを読むのが趣味なのですが、多くのEmacsユーザーは ~EDITOR=emacsclient~ と設定しています。\n\nまた、起動時間のみを考慮するなら =~/.emacs.d/init.el= を削除して素で起動すればよいでしょう。\nそうなると純粋にマシンスペックの勝負になります。\nEmacsは素の状態でも十分魅力的な機能を多数盛り込まれているが、カスタマイズしてこそ真価を発揮するエディタなのでアプローチとしてはイマイチでしょう。\n\nこの記事を読む前に [[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4][Emacs の起動時間を\"\"詰める\"\"]] を熟読することを推奨しています。\n特に次のChapterは非常に有益なテクニックが詰め込まれており、大幅な速度改善を見込めます。\n\n- [[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/abb04ff2351b3564a1a0][autoload と with-eval-after-load]]\n- [[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/c47f8eb7cd547b95ba91][擬似非同期ロードによる\"待たされ感\"改善]]\n- [[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4][その他のテクニック：不要な処理を省くハックたち]]\n\n本のあらすじにも書いてあるとおり、Emacs自体にすでに大量のファイルがある状態で高速に起動する時点で自分の設定を見直さなければならないことは明白でしょう。\n\n#+begin_quote\nしかし、考えてみれば Emacs には 1000 以上の Emacs Lisp ファイルが初めから同梱されているわけで、そこに数十のプラグインを足しただけで爆裂に遅くなるのは、なにか設定にも問題がある気がします。\n#+end_quote\n\n詳細は後述しますが、現在の私のEmacsは15〜25ms程度で起動をします。\n一切設定を読まずに素で起動するコマンド ~emacs -Q~ で起動させると2ms程度です。\nまだまだ高速に起動させる余地はありますが、「高速に起動させることができている」と自負しても問題ないでしょう。\n\n#+begin_example\n  Emacs booting time: 20 [msec] = ‘emacs-init-time’.\n  Loading init files: 10 [msec], of which 1 [msec] for ‘after-init-hook’.\n#+end_example\n\n* 前提\n** 環境\n\n2022年12月現在、 ~Macbook Pro 16-inch, 2019~ の標準モデルを使っています。\n\n#+begin_src shell\n  $ neofetch\n                      'c.          take@obaranoMacBook-Pro.local\n                   ,xNMM.          -----------------------------\n                 .OMMMMo           OS: macOS 13.1 22C65 x86_64\n                 OMMM0,            Host: MacBookPro16,1\n       .;loddo:' loolloddol;.      Kernel: 22.2.0\n     cKMMMMMMMMMMNWMMMMMMMMMM0:    Uptime: 1 day, 18 hours, 29 mins\n   .KMMMMMMMMMMMMMMMMMMMMMMMWd.    Packages: 347 (brew)\n   XMMMMMMMMMMMMMMMMMMMMMMMX.      Shell: fish 3.5.1\n  ;MMMMMMMMMMMMMMMMMMMMMMMM:       Resolution: 1792x1120@2x\n  :MMMMMMMMMMMMMMMMMMMMMMMM:       DE: Aqua\n  .MMMMMMMMMMMMMMMMMMMMMMMMX.      WM: Quartz Compositor\n   kMMMMMMMMMMMMMMMMMMMMMMMMWd.    WM Theme: Blue (Dark)\n   .XMMMMMMMMMMMMMMMMMMMMMMMMMMk   Terminal: tmux\n    .XMMMMMMMMMMMMMMMMMMMMMMMMK.   CPU: Intel i7-9750H (12) @ 2.60GHz\n      kMMMMMMMMMMMMMMMMMMMMMMd     GPU: Intel UHD Graphics 630, AMD Radeon Pro 5300M\n       ;KMMMMMMMWXXWMMMMMMMk.      Memory: 9716MiB / 16384MiB\n         .cooc,.    .,coo:.\n#+end_src\n\nEmacsのversionは ~30.0.50~ です。\n日々HEAD buildをしているので最新のversionとは微妙に差異がありますが、起動速度にはそこまで大きな差が出ないでしょう。\n\n#+begin_src shell\n  $ emacs -version\n  GNU Emacs 30.0.50\n  Development version 6a390fd42ec4 on master branch; build date 2022-12-17.\n  Copyright (C) 2022 Free Software Foundation, Inc.\n  GNU Emacs comes with ABSOLUTELY NO WARRANTY.\n  You may redistribute copies of GNU Emacs\n  under the terms of the GNU General Public License.\n  For more information about these matters, see the file named COPYING.\n#+end_src\n\n** 設定について\n\n- [[https://github.com/takeokunn/.emacs.d][takeokunn/.emacs.d]]\n- [[https://emacs.takeokunn.org/][init.el]]\n- [[https://emacs.takeokunn.org/early-init][early-init]]\n\n2022年現在、 ~init.el~ と ~early-init.el~ は6800行（空白を除くと5800行）程度あります。\n設定を別ファイルに切り分けたりしておらず、 ~init.el~ 1つで管理をしています。\n\nすべての設定を ~org-mode~ で管理しており、GitHub ActionsでbuildをしGitHub Pagesにhostingしています。\n\n~el-get~ で導入しているpackage数は384個です。\n\n#+begin_src shell\n  $ ls -l ~/.emacs.d/el-get | wc -l\n       384\n#+end_src\n\n* 起動速度の測り方\n** そもそも起動速度とはなんなのか\n\nEmacsはざっくり次のような起動プロセスを踏みます。\n\n- boot処理（C言語）\n- [[https://github.com/emacs-mirror/emacs/blob/master/lisp/startup.el][lisp/startup.el]] が読み込まれる\n- [[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L577-L850][normal-top-level]] が実行される\n- [[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1125-L1639][command-line]] が実行される\n- =~/.emacs.d/early-init.el= が読み込まれる\n  - [[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1358-L1367][https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1358-L1367]]\n- =~/.emacs.d/init.el= が読み込まれる\n  - [[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1482-L1507][https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1482-L1507]]\n\nEmacs自体にpatchを当てない限り、 =~/.emacs.d/early-init.el= より前には手が出せません。\n[[https://github.com/emacs-mirror/emacs/blob/master/lisp/proced.el][lisp/proced.el]] のような既存のEmacs Lispファイルは[[https://www.emacswiki.org/emacs/DumpingEmacs][portable dumper]]ですでに実行可能なbinaryに出力されており、fileをloadすることなく実行されているようです。\n\nEmacsのbuild時に自分の ~init.el~ を読み込ませて ~pdump~ を生成するのが真の最速であり、5ms以内での起動を期待できます。\nたとえ記述がほぼないとしても ~init.el~ と ~early-init.el~ を読み込み実行するというのは重いもので、File I/Oというのは重いものだと実感させられました。\nしかし、それではEmacsのカスタマイズ性というのを殺すことになるので今回は含めないこととします。\n\n** 計測方法\n\n~init.el~ に次のようなコードを記述します。\n\n#+begin_src emacs-lisp\n  (defconst my/before-load-init-time (current-time))\n\n  ;;;###autoload\n  (defun my/load-init-time ()\n    \"Loading time of user init files including time for `after-init-hook'.\"\n    (let ((time1 (float-time\n                  (time-subtract after-init-time my/before-load-init-time)))\n          (time2 (float-time\n                  (time-subtract (current-time) my/before-load-init-time))))\n      (message (concat \"Loading init files: %.0f [msec], \"\n                       \"of which %.f [msec] for `after-init-hook'.\")\n               (* 1000 time1) (* 1000 (- time2 time1)))))\n  (add-hook 'after-init-hook #'my/load-init-time t)\n\n  (defvar my/tick-previous-time my/before-load-init-time)\n\n  ;;;###autoload\n  (defun my/tick-init-time (msg)\n    \"Tick boot sequence at loading MSG.\"\n    (when my/loading-profile-p\n      (let ((ctime (current-time)))\n        (message \"---- %5.2f[ms] %s\"\n                 (* 1000 (float-time\n                          (time-subtract ctime my/tick-previous-time)))\n                 msg)\n        (setq my/tick-previous-time ctime))))\n\n  (defun my/emacs-init-time ()\n    \"Emacs booting time in msec.\"\n    (interactive)\n    (message \"Emacs booting time: %.0f [msec] = `emacs-init-time'.\"\n             (* 1000\n                (float-time (time-subtract\n                             after-init-time\n                             before-init-time)))))\n\n  (add-hook 'after-init-hook #'my/emacs-init-time)\n#+end_src\n\n参考記事はこちら。\n\n- [[https://memo.sugyan.com/entry/20120120/1327037494][起動時間を計測する 改訂版 - すぎゃーんメモ]]\n- [[https://github.com/takaxp/emacs.d/blob/master/init.org#241-emacs-%E8%B5%B7%E5%8B%95%E6%99%82%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E9%A0%86][init.org - takaxp/emacs.d]]\n\nそうすると起動後 ~*Minibuffer*~ に起動時間の出力がされるはずです。\n\n#+begin_example\n  Emacs booting time: 20 [msec] = ‘emacs-init-time’.\n  Loading init files: 10 [msec], of which 1 [msec] for ‘after-init-hook’.\n#+end_example\n\n** 評価のし方\n\n高速化する上で重要なのは、評価指標をマシンスペックに依存しない形で評価をすることでしょう。\n\n次のような ~init.el~ を作成すれば、起動時にどのような処理が行われているのか知ることができます。\n\n~init.el~:\n\n#+begin_src emacs-lisp\n  (require 'profiler)\n  (profiler-start 'cpu)\n\n  ;;; --------- 処理中略 ---------\n\n  (profiler-report)\n  (profiler-stop)\n#+end_src\n\n上記のような、処理が空の ~init.el~ を用意して起動すると次のようなreport bufferが起動するでしょう。\n\n#+begin_example\n  Samples    %   Function\n        7 100% - normal-top-level\n        7 100%  - command-line\n        7 100%   - startup--load-user-init-file\n        7 100%    - load\n        7 100%       byte-code\n        0   0% + ...\n#+end_example\n\n多少ブレがあるものの、自分の ~init.el~ で実行をするとSamples数が15以内で起動します。\nSample数が素に近ければ近いほど、高速に動いているといえます。\n\n* この記事で達成する目標\n\n皆さんのEmacsの起動速度はどうでしょうか？\n私の感覚になりますが、だいたい次のように分類できるでしょう。\n\n- 5000ms以上\n  - だいぶ遅い\n  - 外部への通信（パッケージの更新等）が多数走ってしまっている可能性が高い\n- 1000ms 〜 5000ms\n  - 一般的な速度\n  - だいたいのEmacsユーザーはこの辺だろう\n  - パッケージ管理ツールを普通に使って普通に設定しているとこのくらい\n- 100ms 〜 1000ms\n  - パッケージ管理ツールで高速化をするとだいたいこの辺になる\n  - そこそこ頑張る必要がある\n- 100ms以下\n  - すべての設定をパッケージ管理ツールを使わずに素で書いているか、高速化にこだわった設定をしている\n  - かなり頑張る必要がある\n  - ~EDITOR=emacs~ 設定するのを視野に入れられる\n\n[[https://qiita.com/delphinus/items/fb905e452b2de72f1a0f#3-%E3%81%93%E3%81%AE%E8%A8%98%E4%BA%8B%E3%81%A7%E9%81%94%E6%88%90%E3%81%99%E3%82%8B%E7%9B%AE%E6%A8%99][NeoVimの場合]]はこちら。\nNeovimでは「50ms以下」から「500ms以上」を話題にしているので明らかにEmacsはスタート地点が遅い。\n\nこの記事では当然100ms以下を目指している。\n\n* 具体的なアプローチ方法\n** パッケージ管理ツールについて\n\n多くの人は ~use-package~ や ~leaf~ を使っていることでしょう。\n~use-package~ の実態はパッケージ管理ツールというよりはmacroです。\n\n~use-package~ 内に適切の設定を記述すると、パッケージを落としパスを通し、関数や変数の設定を記述したりする ~s式~ を生成してくれます。\n私は ~use-package~ には疎いので正確なことは書けませんが、~s式~ の効率がよいかといわれたら最高速をたたき出せるものではありません。\n\n普通にEmacsの設定をするなら間違いなく使うべきものですが、今回のようなパフォーマンスを求める場合あまりお勧めできるものではありません。\n\n** NativeComp\n*** EmacsをFull NativeCompでBuildする\n\n多くの人はHomebrewのようなパッケージマネージャーで落してBuildしたEmacsを使っていることでしょう。\nそれだと細かいbuildの設定もできないし、かゆい所に手が届きません。\n\nまずは ~git clone~ をします。\n\n#+begin_src shell\n  $ git clone git://git.sv.gnu.org/emacs.git\n  $ cd emacs\n#+end_src\n\n次にNativeCompでbuildします。\n私は毎日 ~git pull~ したうえで次のコマンドを叩いてbuildしています。\n\n#+begin_src shell\n  $ ./autogen.sh && ./configure --with-native-compilation=aot --without-ns --without-x --with-libxml2=/usr/bin/xml2-config && make -j8\n  $ sudo make install\n#+end_src\n\n~--with-native-compilation=aot~ が特に重要です。\n\n[[https://blog.tomoya.dev/posts/hello-native-comp-emacs/][ネイティブコンパイルEmacsの登場]]に書いてありますが、2021年4月ころにNative Compがサポートされました。\n~foo.el~ というファイルから ~foo.eln~ という拡張子のファイルを生成します。\n~brew install libgccjit~ などをしてちゃんと ~libgccjit~ をinstallする必要があります。\n[[https://www.grugrut.net/posts/202104272222/][EmacsのNative Compilationの性能を測定する]]でも検証されているが、かなりの高速化が期待できます。\n\n[[https://github.com/emacs-mirror/emacs/commit/e245c4f226979ccb717cccc8f82b2b0a0f96bdac][Add --with-native-compilation=aot configuration option]] で ~aot~ を指定してbuildするとEmacsのFull Native Compが実行されるようになりました。\n~make -j <proc>~ でproc数を多くすると処理が重すぎてPCが固まるので少なめに設定しておく方がよいです。\n\n*** NativeCompした結果のファイル（eln）が優先的に読み込まれる\n\nEmacs Lispで別のファイルを呼び込む際に ~(load \"/path/to/dir/file\")~ のように書きます。\n\n実際に、[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1125-L1639][command-line]]から ~init.el~ や ~early-init.el~ を読み込む時にも ~load~ は使われています。\n\n[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1011-L1120][コード(startup--load-user-init-file)]]はここです。\n\n[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/src/lread.c#L1173-L1628][load関数の定義]] を見てみると、優先的に ~.eln~ を読むようになっているようなので早めにNativeCompする必要があります。\n\n*** init.elとearly-init.elをbyte-compileする\n\n[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/972544d4b66cf5c1a75c][バイトコンパイル - Emacs の起動時間を\"\"詰める\"\"]]について。\n\nByte Compileの[[https://ayatakesi.github.io/emacs/24.5/elisp_html/Byte-Compilation.html][ドキュメント]]には次のような記述があります。\n\n#+begin_quote\nEmacs Lispには、Lispで記述された関数を、より効率的に実行できるバイトコード(byte-code)と呼ばれる特別な表現に翻訳するコンパイラー(compiler)があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義はバイトコードインタープリター(byte-code interpreter)により評価されます。\n#+end_quote\n\nこんな感じでbyte-compileするとよいです。\n\n#+begin_src shell\n  $ emacs -Q --batch -f batch-byte-compile early-init.el\n  $ emacs -Q --batch -f batch-byte-compile init.el\n#+end_src\n\n基本的にはnative compが優先的に読まれるので意味がないといわれたらそうなのですが、後述する ~el-get~ はbyte-compile時に発行させるので流す必要があります。\n\n*** NativeCompの設定\n\n~native-comp-speed~ と ~native-comp-async-jobs-number~ を設定するとよいです。\n\n~native-comp-speed~ は最適化オプションで0〜3があります。\n[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/emacs-lisp/comp.el#L46-L58][ソースコード]]はこちら。\n「Warning: with 3, the compiler is free to perform dangerous optimizations.」と書いてありますが、半年以上この設定で問題なく使えているので気にしなくてよいでしょう。\n\n~native-comp-async-jobs-number~ はjob数で大きめに設定するとPCが極端に重くなってしまうので低めに設定しておくことをお勧めします。\n\n#+begin_src emacs-lisp\n  (with-eval-after-load 'comp\n    (setq native-comp-async-jobs-number 8)\n    (setq native-comp-speed 3))\n#+end_src\n\n*** init.elとearly-init.elをNativeCompする\n\n~native-compile-async~ でNativeCompileできます。\nコンパイル結果の出力は ~*Async-native-compile-log*~ bufferです。\n\n#+begin_src emacs-lisp\n  (native-compile-async \"~/.emacs.d/init.el\")\n  (native-compile-async \"~/.emacs.d/early-init.el\")\n#+end_src\n** early-init.elについて\n\n[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4#early-init.el][early-init.el - Emacs の起動時間を\"\"詰める\"\"]]について。\n\n~early~ と書いてあるとおり、初期段階で読み込まれるものです。\n「初期段階」で読み込まれるとは具体的に何でしょうか？\n~early-init.el~ に書くべき処理とそうでない処理の違いとはなんなのでしょうか？\n\n[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][49.4.6 The Early Init File]]には次のように記述されています。\n\n#+begin_quote\nBy contrast, the normal init files are read after the GUI is initialized.\n#+end_quote\n\n要するに「GUIを初期化するより前に読み込まれる」としか書いてないです。\n\n~early-init.el~ と ~init.el~ が読み込まれる間のコードを読むしかないです。\n\n[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1369-L1479][https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1369-L1479]]\n\n実行されている主な関数は以下。\n\n- startup--update-eln-キャッシュ\n- package-activate-all\n- window-system-initialization\n- frame-initialize\n- tool-bar-setup\n- normal-erase-is-backspace-setup-frame\n- tty-register-default-colors\n\nこの辺に関係する設定をすればよいでしょう。\n\nまたC言語側のコードは先に読まれるはずです。\nGC関係のコードは[[https://github.com/emacs-mirror/emacs/blob/master/src/alloc.c][src/alloc.c]]に記述されているので、 ~gc-cons-threshold~ は ~early-init.el~ に書く方がよいです。\n\n余談ですが、EXWM環境の場合 ~(setq frame-inhibit-implied-resize t)~ をするとEXWMがwindow resizeできなくなるので描画がおかしくなるので注意が必要です。\n\n** Compile時処理\n*** el-get-bundleをeval-when-compile時に落とす\n\n私は ~el-get~ ユーザーなので別のpackage managerのことはわかりませんが、package installはbyte-compile時に行っています。\n[[https://github.com/dimitri/el-get][dimitri/el-get]]の ~Installation~ を参考に設定していきます。\n\n~eval-when-compile~ はbyte-compile時にしか発行せず、生成された ~elc~ には処理結果が記述されるというものです。\n\n私は ~el-get~ で380個程度のpackageを落としている関係上、非常に時間がかかるのでshallow cloneするようにしています。\n\n#+begin_src emacs-lisp\n  (eval-when-compile\n    (add-to-list 'load-path (locate-user-emacs-file \"el-get/el-get\"))\n    (with-current-buffer\n        (url-retrieve-synchronously\n         \"https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el\")\n      (goto-char (point-max))\n      (eval-print-last-sexp))\n\n    (with-eval-after-load 'el-get-git\n      (setq el-get-git-shallow-clone t)))\n#+end_src\n\n実際にinstallするpackageは次のように記述しています。\n\n#+begin_src emacs-lisp\n  (eval-when-compile\n    (el-get-bundle \"yasnippet\"))\n\n  (eval-when-compile\n    (el-get-bundle takeokunn/yasnippet-org))\n#+end_src\n\n*** 環境ごとのif文をmacroで定義する\n\n私のEmacs環境は3つあります。\n\n- Mac CLI環境\n- Mac GUI環境\n- Guix exwm環境\n\n前提にも書いたとおり、今回高速化するにあたって「Mac CLI環境」にフォーカスして話していたが、実際運用している環境は3つあります。\nたとえば「Mac環境ではexwm関係のpluginは不要」のような、環境ごとに必要な処理やライブラリが微妙に違うので条件分岐が必要になってきます。\n\n3環境を分岐できるようなmacroを作成し、byte-compile時に条件分岐しました。\n\n#+begin_src emacs-lisp\n  ;;; Mac CLI環境\n  (defmacro when-darwin (&rest body)\n    (when (string= system-type \"darwin\")\n      `(progn ,@body)))\n\n  ;;; Mac GUI環境\n  (defmacro when-darwin-not-window-system (&rest body)\n    (when (and (string= system-type \"darwin\")\n               window-system)\n      `(progn ,@body)))\n\n  ;;; Guix exwm環境\n  (defmacro when-guix (&rest body)\n    (when (string= system-type \"guix\")\n      `(progn ,@body)))\n#+end_src\n\n** ライブラリ周りの読み込み\n*** async loadをする\n\n[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/c47f8eb7cd547b95ba91][擬似非同期ロードによる\"待たされ感\"改善 - Emacs の起動時間を\"\"詰める\"\"]] について。\n\n~run-with-timer~ で起動n秒後にqueue内の処理を順次実行するというアプローチです。\n\n私はpackageを380個程度入れているので、起動した瞬間に使いたいpackageがなかなかdequeueしてくれないという問題が出てきました。\n早く読まれてほしいpackageが以下です。\n\n- dash.elやs.elのようなbasic packages\n- amx\n- magit\n- ddskk\n- projectile\n- swiper/ivy/counsel\n- doom\n\n普通にEmacsを起動した時最初にたたくコマンドは ~projectile~ であることや、 ~EDITOR=emacs git commit~ で立ち上がった時さっさと日本語入力できるようにしたいものです。\nまた、fish shellから ~M-g~ でmagitを起動できるようしています。\n\n#+begin_src fish\n  function magit\n      set -l git_root (git rev-parse --show-toplevel)\n      emacs -nw --eval \"\n  (progn\n    (add-to-list 'load-path (locate-user-emacs-file \\\"el-get/dash\\\"))\n    (add-to-list 'load-path (locate-user-emacs-file \\\"el-get/compat\\\"))\n    (add-to-list 'load-path (locate-user-emacs-file \\\"el-get/transient/lisp\\\"))\n    (add-to-list 'load-path (locate-user-emacs-file \\\"el-get/ghub/lisp\\\"))\n    (add-to-list 'load-path (locate-user-emacs-file \\\"el-get/magit-pop\\\"))\n    (add-to-list 'load-path (locate-user-emacs-file \\\"el-get/with-editor/lisp\\\"))\n    (add-to-list 'load-path (locate-user-emacs-file \\\"el-get/magit/lisp\\\"))\n    (require 'magit)\n    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1) (magit-status \\\"$git_root\\\"))\"\n  end\n\n\n  function fish_user_key_bindings\n      bind \\eg magit\n  end\n#+end_src\n\n元記事を参考に優先順位高いqueueを処理する機構も作りました。\n\n#+begin_src emacs-lisp\n  (defvar my/delayed-priority-high-configurations '())\n  (defvar my/delayed-priority-high-configuration-timer nil)\n\n  (defvar my/delayed-priority-low-configurations '())\n  (defvar my/delayed-priority-low-configuration-timer nil)\n\n  (add-hook 'emacs-startup-hook\n            (lambda ()\n              (setq my/delayed-priority-high-configuration-timer\n                    (run-with-timer\n                     0.1 0.001\n                     (lambda ()\n                       (if my/delayed-priority-high-configurations\n                           (let ((inhibit-message t))\n                             (eval (pop my/delayed-priority-high-configurations)))\n                         (progn\n                           (cancel-timer my/delayed-priority-high-configuration-timer))))))\n              (setq my/delayed-priority-low-configuration-timer\n                    (run-with-timer\n                     0.3 0.001\n                     (lambda ()\n                       (if my/delayed-priority-low-configurations\n                           (let ((inhibit-message t))\n                             (eval (pop my/delayed-priority-low-configurations)))\n                         (progn\n                           (cancel-timer my/delayed-priority-low-configuration-timer))))))))\n\n  (defmacro with-delayed-execution-priority-high (&rest body)\n    (declare (indent 0))\n    `(setq my/delayed-priority-high-configurations\n           (append my/delayed-priority-high-configurations ',body)))\n\n  (defmacro with-delayed-execution (&rest body)\n    (declare (indent 0))\n    `(setq my/delayed-priority-low-configurations\n           (append my/delayed-priority-low-configurations ',body)))\n#+end_src\n\n*** autoload/with-eval-after-loadを活用する\n\n[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/abb04ff2351b3564a1a0][autoload と with-eval-after-load - Emacs の起動時間を\"\"詰める\"\"]]について。\n\n~autoload~ の挙動は上記の記事に詳細に書かれているので省きます。\nただ、 ~autoload~ というのは1つの関数名しか引数に取れないので非常に不便です。\n次のような ~autoload-if-found~ という関数を作成ました。\n\n#+begin_src emacs-lisp\n  (defun autoload-if-found (functions file &optional docstring interactive type)\n    \"set autoload iff. FILE has found.\"\n    (when (locate-library file)\n      (dolist (f functions)\n        (autoload f file docstring interactive type))\n      t))\n#+end_src\n\n使い方はこんな感じです。\n\n#+begin_src emacs-lisp\n  (autoload-if-found '(lsp lsp-deferred) \"lsp-mode\" nil t)\n#+end_src\n\n~with-eval-after-load~ は ~require~ が実行されたタイミングで読まれるものです。\n~autolaod-if-found~ ですべての処理を遅延している関係で、すべてのpackageに対して丁寧に指定する必要があります。\nもし設定をしなければ、未定義変数になって起動時にWarningなりErrorが吐かれてしまいます。\n\n次の ~php-mode-~ の例のように、 ~with-eval-after-load~ には3種類の設定をするようにしています。\n\n- hook\n- keybind（map）\n- custom\n\n#+begin_src emacs-lisp\n  (with-eval-after-load 'php-mode\n    ;; hook\n    (add-hook 'php-mode-hook #'lsp-deferred)\n\n    ;; keybind\n    (define-key php-mode-map (kbd \"C-c C--\") #'php-current-class)\n    (define-key php-mode-map (kbd \"C-c C-=\") #'php-current-namespace)\n\n    ;; config\n    (setq php-mode-coding-style 'psr2))\n#+end_src\n\n** 設定\n*** Magic File Name を一時的に無効にする\n\n[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4#magic-file-name-%E3%82%92%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AB%E7%84%A1%E5%8A%B9%E3%81%AB%E3%81%99%E3%82%8B][Magic File Name を一時的に無効にする - Emacs の起動時間を\"\"詰める\"\"]] について。\n\nFileのI/Oは非常にコストがかかる行為だとあらためて感じました。\n\n次の記述を書くだけです。\n書くだけでかなり改善するのでコスパのよい対応だと感じています。\n\n#+begin_src emacs-lisp\n  ;;; 行頭\n  (defconst my/saved-file-name-handler-alist file-name-handler-alist)\n  (setq file-name-handler-alist nil)\n\n  ;;; 行末\n  (setq file-name-handler-alist my/saved-file-name-handler-alist)\n#+end_src\n\n*** GCの設定\n\n[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4#gc-%E3%82%92%E6%B8%9B%E3%82%89%E3%81%99][GC を減らす - Emacs の起動時間を\"\"詰める\"\"]]について。\n\n起動時にGCが回ることはっきり言ってコストでしかないです。\n起動時に一度もGCを回さない程度の大きさで設定しておくとよいです。\n\nGCが回ったかどうかは前述の「評価のし方」で ~profile-report~ が出力してくれるので、そこで判断できるでしょう。\n私は ~early-init.el~ に次のように設定しています。\n\n#+begin_src emacs-lisp\n  (setq gc-cons-threshold (* 128 1024 1024))\n#+end_src\n\n* その他\n** add-to-listについて\n\n[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/395aeb41a34a616f58bd#%E5%AE%89%E5%85%A8%E3%81%AA%E9%96%A2%E6%95%B0%E3%82%92%E8%AB%A6%E3%82%81%E3%82%8B][安全な関数を諦める - Emacs の起動時間を\"\"詰める\"\"]] について。\n\n~add-to-list~ を使わずに ~push~ を使うほうが重複チェックを行わない関係で速くなるということが書かれています。\n\n~add-to-list~ はプログラミング言語の ~major-mode~ や ~mior-mode~ で設定する時に使うことが多いです。\n私は数十のpackageを入れているのですが、 ~push~ に置き換えて事故って動かなくなったことがあります。\n\n重複チェックをするかどうかで変わる秒数は1msよりも圧倒的に少ないだろうし、安全性を捨てるデメリットと比較してメリットが薄いように感じているので却下しました。\n\nまたasync loadしている関係で言語系の処理は遅延読み込みしているので、起動時には影響が出ないです。\n\n** Porテーブル Dumperについて\n\n[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/e27557c39fceefe6c4f6#%E3%83%9D%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB%E3%83%80%E3%83%B3%E3%83%91%E3%83%BC][ポータブルダンパー - Emacs の起動時間を\"\"詰める\"\"]] について。\n\nあらかじめpackageを読み込んでおいた状態のmemoryをdumpするしくみ。\n今回の遅延評価をするアプローチでは ~Portable Dumper~ は活躍できませんでした。\n\n記述量がほぼない状態のEmacs Lispファイルを用意してmemory dumpして読み込ませてみたところ、180ms程度かかりました。\n\nそもそもNativeCompしているライブラリはdumpできなかったりといろいろな落とし穴があるらしく、非常に使いにくいものとなっています。\nEmacsを自前Buildしたタイミングで生成されるdumpに自分のコードを埋め込むくらいすれば高速になりますが、別途用意をすると非常に遲くなります。\n\n** lsp-modeのperformanceについて\n\n今回の起動時の高速化には関係ないが、 ~lsp-mode~ を高速化するTipsが公式サイトにあります。\n私は ~lsp-mode~ をヘビーユーズしているので、パフォーマンスが大幅に改善されて生産性が上がりました。\n\n[[https://emacs-lsp.github.io/lsp-mode/page/performance/][Performance - lsp-mode]]\n\n** el-getのpackageもNativeCompする\n\nこれも今回の起動時の高速化には関係ないが、el-getで落としてきたpackageも一括でNativeCompする方がよいでしょう。\n次のような関数を用意し、あらかじめ実行しておくとよいです。\n\n~el-get/**/*.el~ と ~elpa/**/*.el~ のすべてのファイルを再帰的にNativeCompするため時間がかかります。\n\n#+begin_src emacs-lisp\n  (defun my/native-comp-packages ()\n    (interactive)\n    (native-compile-async \"~/.emacs.d/init.el\")\n    (native-compile-async \"~/.emacs.d/early-init.el\")\n    (native-compile-async \"~/.emacs.d/el-get\" 'recursively)\n    (native-compile-async \"~/.emacs.d/elpa\" 'recursively))\n#+end_src\n* 終わりに\n\n2022年はEmacsとひたすら向きあった1年でした。\n今後10〜15年耐えられる設定とはなんなのかを考えた結果の1つに「起動時間の高速化」というのがありました。\nゼロから設定を見直し、より高速かつメンテナンス性の高い記述方法はなんなのか、 ~emacs.d~ はどうあるべきか、より善く生きていくためにはどうすればよいのかを考えつくしました。\n\nEmacs起動時間を高速化するにあたって、Emacs本体のソースコードを読む機会が増えて多くの知識を得ることができました。\nぜひ皆さんも自分の設定をあらためて見直すきっかけにしていただけると幸いです。\n\nいつもTwitterで疑問に答えてくれるEmacs Hackerの皆さんのおかげでこの記事を書くことができました。\n今後ともよろしくお願いします。\n",
  "backlinks": []
}