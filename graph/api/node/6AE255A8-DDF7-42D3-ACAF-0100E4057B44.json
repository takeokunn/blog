{
  "id": "6AE255A8-DDF7-42D3-ACAF-0100E4057B44",
  "title": "emacsでuniversal-ctagsを使う",
  "raw": ":PROPERTIES:\n:ID:       6AE255A8-DDF7-42D3-ACAF-0100E4057B44\n:END:\n#+TITLE: emacsでuniversal-ctagsを使う\n#+AUTHOR: takeokunn\n#+DESCRIPTION: description\n#+DATE: 2025-04-09T23:58:30+0900\n#+HUGO_BASE_DIR: ../../\n#+HUGO_CATEGORIES: fleeting\n#+HUGO_SECTION: posts/fleeting\n#+HUGO_TAGS: fleeting emacs\n#+HUGO_DRAFT: false\n#+STARTUP: fold\n* Introduction\n\n[[https://github.com/universal-ctags/ctags][universal-ctags/ctags]] の検証をしたのでメモしておく。\n\n* 概要\nWikipedia的には以下。\nhttps://ja.wikipedia.org/wiki/Ctags\n\n#+begin_quote\nCtags（英: Ctags）はソース及びヘッダ内にある名前のインデックス（又はタグ）ファイルを生成するプログラム。様々なプログラミング言語に対応している。言語に依存するが、サブルーチン(関数)、変数、クラスのメンバ、マクロ等がインデックス化される。これらのタグによりテキストエディタなどのツールで高速かつ容易に定義を参照できる。相互参照ファイルを出力でき、また名前についての情報を人が読みやすい形で列挙した言語ファイルを生成することもできる。\n\nCtagsはケン・アーノルドがBSD Unix用に開発した。後にJim KlecknerによりFortranがサポートされ、ビル・ジョイによりPascalがサポートされた。\n#+end_quote\n\nuniversal-ctagsは「A maintained ctags implementation」と自称しているとおり、2025年4月現在も活発にメンテナンスされている。\nhttps://github.com/universal-ctags/ctags\n\n* universal-ctags使い方\n\nNix経由なら簡単に実行できる。\nhttps://search.nixos.org/packages?channel=24.11&show=universal-ctags&from=0&size=50&sort=relevance&type=packages&query=universal-ctags\n\n#+begin_src console\n  $ nix run nixpkgs#universal-ctags -- --version\n\n  Universal Ctags 6.1.0, Copyright (C) 2015-2023 Universal Ctags Team\n  Universal Ctags is derived from Exuberant Ctags.\n  Exuberant Ctags 5.8, Copyright (C) 1996-2009 Darren Hiebert\n    URL: https://ctags.io/\n    Output version: 0.0\n    Optional compiled features: +wildcards, +regex, +gnulib_fnmatch, +gnulib_regex, +iconv, +option-directory, +xpath, +json, +interactive, +yaml, +case-insensitive-filenames, +packcc, +optscript, +pcre2\n#+end_src\n\nPHPプロジェクトである [[https://github.com/bobthecow/psysh][bobthecow/psysh]] を例に =TAGS= を生成する。\n\n#+begin_src console\n  $ nix run nixpkgs#universal-ctags -- -R --languages=+php,-python -e .\n#+end_src\n\n=-e= オプションはEmacs用。\n\n#+begin_src console\n  -e   Output tag file for use with Emacs.\n#+end_src\n\nたとえば =src/CodeCleaner.php= は次のように出力される。\nhttps://github.com/bobthecow/psysh/blob/85057ceedee50c49d4f6ecaff73ee96adb3b3625/src/CodeCleaner.php\n\n#+begin_src console\n  $ nix run nixpkgs#universal-ctags -- -R --languages=+php,-python -e src/CodeCleaner.php\n  $ cat -p TAGS\n\n  src/CodeCleaner.php,3540\n  namespace Psy;^?Psy^A12,215\n  use PhpParser\\NodeTraverser;^?NodeTraverser^A14,231\n  use PhpParser\\Parser;^?Parser^A15,260\n  use PhpParser\\PrettyPrinter\\Standard as Printer;^?Printer^A16,282\n  use Psy\\CodeCleaner\\AbstractClassPass;^?AbstractClassPass^A17,331\n  use Psy\\CodeCleaner\\AssignThisVariablePass;^?AssignThisVariablePass^A18,370\n  use Psy\\CodeCleaner\\CalledClassPass;^?CalledClassPass^A19,414\n  use Psy\\CodeCleaner\\CallTimePassByReferencePass;^?CallTimePassByReferencePass^A20,451\n  use Psy\\CodeCleaner\\CodeCleanerPass;^?CodeCleanerPass^A21,500\n  use Psy\\CodeCleaner\\EmptyArrayDimFetchPass;^?EmptyArrayDimFetchPass^A22,537\n  use Psy\\CodeCleaner\\ExitPass;^?ExitPass^A23,581\n  use Psy\\CodeCleaner\\FinalClassPass;^?FinalClassPass^A24,611\n  use Psy\\CodeCleaner\\FunctionContextPass;^?FunctionContextPass^A25,647\n  use Psy\\CodeCleaner\\FunctionReturnInWriteContextPass;^?FunctionReturnInWriteContextPass^A26,688\n  use Psy\\CodeCleaner\\ImplicitReturnPass;^?ImplicitReturnPass^A27,742\n  use Psy\\CodeCleaner\\IssetPass;^?IssetPass^A28,782\n  use Psy\\CodeCleaner\\LabelContextPass;^?LabelContextPass^A29,813\n  use Psy\\CodeCleaner\\LeavePsyshAlonePass;^?LeavePsyshAlonePass^A30,851\n  use Psy\\CodeCleaner\\ListPass;^?ListPass^A31,892\n  use Psy\\CodeCleaner\\LoopContextPass;^?LoopContextPass^A32,922\n  use Psy\\CodeCleaner\\MagicConstantsPass;^?MagicConstantsPass^A33,959\n  use Psy\\CodeCleaner\\NamespacePass;^?NamespacePass^A34,999\n  use Psy\\CodeCleaner\\PassableByReferencePass;^?PassableByReferencePass^A35,1034\n  use Psy\\CodeCleaner\\RequirePass;^?RequirePass^A36,1079\n  use Psy\\CodeCleaner\\ReturnTypePass;^?ReturnTypePass^A37,1112\n  use Psy\\CodeCleaner\\StrictTypesPass;^?StrictTypesPass^A38,1148\n  use Psy\\CodeCleaner\\UseStatementPass;^?UseStatementPass^A39,1185\n  use Psy\\CodeCleaner\\ValidClassNamePass;^?ValidClassNamePass^A40,1223\n  use Psy\\CodeCleaner\\ValidConstructorPass;^?ValidConstructorPass^A41,1263\n  use Psy\\CodeCleaner\\ValidFunctionNamePass;^?ValidFunctionNamePass^A42,1305\n  use Psy\\Exception\\ParseErrorException;^?ParseErrorException^A43,1348\n  class CodeCleaner^?CodeCleaner^A49,1550\n      private bool $yolo = false;^?yolo^A51,1570\n      private bool $strictTypes = false;^?strictTypes^A52,1602\n      private Parser $parser;^?parser^A54,1642\n      private Printer $printer;^?printer^A55,1670\n      private NodeTraverser $traverser;^?traverser^A56,1700\n      private ?array $namespace = null;^?namespace^A57,1738\n      public function __construct(?Parser $parser = null, ?Printer $printer = null, ?NodeTraverser^?__construct^A68,2359\n      public function yolo(): bool^?yolo^A85,2982\n      private function getDefaultPasses(): array^?getDefaultPasses^A95,3151\n      private function addImplicitDebugContext(array $passes)^?addImplicitDebugContext^A159,5472\n      private static function getDebugFile()^?getDebugFile^A195,6446\n      private static function isDebugCall(array $stackFrame): bool^?isDebugCall^A219,7096\n      public function clean(array $codeLines, bool $requireSemicolons = false)^?clean^A238,7790\n      public function setNamespace(?array $namespace = null)^?setNamespace^A263,8524\n      public function getNamespace()^?getNamespace^A273,8724\n      protected function parse(string $code, bool $requireSemicolons = false)^?parse^A288,9128\n      private function parseErrorIsEOF(\\PhpParser\\Error $e): bool^?parseErrorIsEOF^A322,10102\n      private function parseErrorIsUnclosedString(\\PhpParser\\Error $e, string $code): bool^?parseErrorIsUnclosedString^A336,10569\n      private function parseErrorIsUnterminatedComment(\\PhpParser\\Error $e, string $code): bool^?parseErrorIsUnterminatedComment^A351,10952\n      private function parseErrorIsTrailingComma(\\PhpParser\\Error $e, string $code): bool^?parseErrorIsTrailingComma^A356,11122\n#+end_src\n\n以下が読み方らしい。\n\n| 行                                                                                        | 説明                                 |\n|-------------------------------------------------------------------------------------------+--------------------------------------|\n| namespace Psy;^?Psy^A12,215                                                               | Psy という名前空間を定義している（行12） |\n| use PhpParser\\Parser;^?Parser^A15,260                                                     | Parser を use している（行15）         |\n| class CodeCleaner^?CodeCleaner^A49,1550                                                   | CodeCleaner クラスの定義（行49）       |\n| private bool $yolo = false;^?yolo^A51,1570                                                | yolo プロパティの定義（行51）           |\n| public function clean（array $codeLines, bool $requireSemicolons = false）^?clean^A238,7790 | clean 関数の定義（行238）              |\n\n* emacsとの繋ぎ込み\n\n特に設定していなくても =<project-root>/TAGS= があれば、任意の関数で =M-x xref-find-definitions(M-.)=  を実行してジャンプできる。\n\nxrefのbackendがetagsになり、次のようにTAGSのPATHを解決してる。\n\n#+begin_src emacs-lisp\n  (expand-file-name \"TAGS\" (locate-dominating-file default-directory \"TAGS\"))\n#+end_src\n\n- https://github.com/emacs-mirror/emacs/blob/master/lisp/progmodes/etags.el\n- https://github.com/emacs-mirror/emacs/blob/master/lisp/progmodes/xref.el\n\nbuffer saveにhookしてctagsを再生成するのが一般的のようだ。\n\n* 終わりに\n思った以上に簡単に使えた。\nphp-srcやvimなどのOSSコードリーディングはLSP重いしこれでよいのかもしれない。\n",
  "backlinks": []
}