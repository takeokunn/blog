{
  "id": "AFA79DCA-DA84-40CA-9C25-FEC5EB2309A5",
  "title": "php-srcとyieldについて調査メモ",
  "raw": ":PROPERTIES:\n:ID:       AFA79DCA-DA84-40CA-9C25-FEC5EB2309A5\n:END:\n#+TITLE: php-srcとyieldについて調査メモ\n#+AUTHOR: takeokunn\n#+DESCRIPTION: description\n#+DATE: 2025-06-25T11:57:47+0900\n#+HUGO_BASE_DIR: ../../\n#+HUGO_CATEGORIES: fleeting\n#+HUGO_SECTION: posts/fleeting\n#+HUGO_TAGS: fleeting php\n#+HUGO_DRAFT: false\n#+STARTUP: fold\n* 背景・動機\n\n[[https://github.com/php/php-src][php/php-src]] でyieldはどう扱われているのか調査したのでメモしておく。\n\n* 試したこと・やったこと\n** RFCを読む\n\n2012/06/05にNikita Popov氏が「Request for Comments: Generators」というRFCを出している。\nyield構文はPHP 5.5で導入されたようだ。\n\nhttps://wiki.php.net/rfc/generators\n\nyieldは次の点で優れているという主張をしている。\n\n- パフォーマンスとメモリ効率\n- 可読性・保守性\n- イテレーション処理の標準化\n\nGeneratorのInterfaceは以下。\nIteratorを継承しているのでforeachでloopを回せる。\n\n#+begin_src php\n  final class Generator implements Iterator {\n      void  rewind();\n      bool  valid();\n      mixed current();\n      mixed key();\n      void  next();\n\n      mixed send(mixed $value);\n      mixed throw(Exception $exception);\n  }\n#+end_src\n\n他言語の実装は以下。\n\n- Python\n  - https://wiki.python.org/moin/Generators\n- ECMAScript\n  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators#Generators:_a_better_way_to_build_Iterators\n- C#\n  - https://csharpindepth.com/Articles/IteratorBlockImplementation\n\n** サンプルコード\n*** 最小サンプル\n#+begin_src php\n  function gen() {\n      yield 1;\n      yield 2;\n      yield 3;\n  }\n\n  $g = gen();\n\n  echo $g->current(); // 1\n  $g->next();\n\n  echo $g->current(); // 2\n  $g->next();\n\n  echo $g->current(); // 3\n  $g->next();\n#+end_src\n*** foreach\n\nIteratorなのでforeachで回せる。\n\n#+begin_src php\n  function keyedGen() {\n      yield 'first'  => 'A';\n      yield 'second' => 'B';\n      yield 'third' => 'C';\n  }\n\n  foreach (keyedGen() as $key => $val) {\n      echo \"$key => $val\\n\";   // first => A / second => B / third => C\n  }\n#+end_src\n*** yield from\n\nyieldの合成可能。\n\n#+begin_src php\n  function sub()\n  {\n      yield 1;\n      yield 2;\n  }\n\n  function main()\n  {\n      yield 0;\n      yield from sub();\n      yield 3;\n  }\n\n  foreach (main() as $v) echo $v; // 0 1 2 3\n#+end_src\n*** CLIアプリ例\n\nyieldを使えば対話式のアプリケーションを簡単に作成できる。\n\n#+begin_src php\n  function interactiveForm() {\n      echo \"フォーム開始\\n\";\n\n      $name = yield \"お名前を入力してください:\";\n      $age  = yield \"年齢を入力してください:\";\n      $lang = yield \"好きな言語を入力してください:\";\n\n      yield \"確認: {$name}さん ({$age}歳)、{$lang}が好きなんですね。\";\n  }\n\n  $gen = interactiveForm();\n\n  while ($gen->valid()) {\n      $prompt = $gen->current();\n      echo $prompt . \"\\n\";\n\n      $input = readline(\"> \");\n      $gen->send($input);\n  }\n#+end_src\n\n#+begin_src console\n  $ nix run nixpkgs#php test.php\n  フォーム開始\n  お名前を入力してください:\n  @> take\n  年齢を入力してください:\n  @> 29\n  好きな言語を入力してください:\n  @> php\n  確認: takeさん (29歳)、phpが好きなんですね。\n  @> yes\n#+end_src\n*** throw例\n\nthrowを投げることもできる。\n\n#+begin_src php\n  function worker() {\n      try {\n          while (true) {\n              $task = yield;\n              echo \"work on $task\\n\";\n          }\n      } catch (Exception $e) {\n          echo \"stop: {$e->getMessage()}\\n\";\n      }\n  }\n\n  $g = worker();  $g->rewind();\n  $g->send('task-1');\n  $g->throw(new Exception('interrupt'));\n#+end_src\n*** 戻り値付き\n#+begin_src php\n  function sum($a, $b) {\n      yield $a;\n      return $a + $b;\n  }\n\n  $g = sum(2, 3);\n  $g->next();\n\n  echo $g->getReturn();\n#+end_src\n** php-srcコードリーディング\n*** コンパイラ\n[[https://github.com/php/php-src/blob/8b61c49987750b74bee19838c7f7c9fbbf53aace/Zend/zend_language_parser.y][Zend/zend_language_parser.y]] に予約語として登録されている。\n\n#+begin_src bison\n  %precedence T_YIELD\n  %precedence T_YIELD_FROM\n#+end_src\n\n次の3つの構文をサポートしている。\n\n- 単純なyield: T_YIELD のみ\n- 値付きyield: T_YIELD expr\n- キー・値付きyield: T_YIELD expr T_DOUBLE_ARROW expr\n\n#+begin_src bison\n  |\tT_YIELD { $$ = zend_ast_create(ZEND_AST_YIELD, NULL, NULL); CG(extra_fn_flags) |= ZEND_ACC_GENERATOR; }\n  |\tT_YIELD expr { $$ = zend_ast_create(ZEND_AST_YIELD, $2, NULL); CG(extra_fn_flags) |= ZEND_ACC_GENERATOR; }\n  |\tT_YIELD expr T_DOUBLE_ARROW expr { $$ = zend_ast_create(ZEND_AST_YIELD, $4, $2); CG(extra_fn_flags) |= ZEND_ACC_GENERATOR; }\n  |\tT_YIELD_FROM expr { $$ = zend_ast_create(ZEND_AST_YIELD_FROM, $2); CG(extra_fn_flags) |= ZEND_ACC_GENERATOR; }\n#+end_src\n\n[[https://github.com/php/php-src/blob/8b61c49987750b74bee19838c7f7c9fbbf53aace/Zend/zend_compile.c#L1530-L1560][Zend/zend_compile.c]] でgenerator関数かどうかを判定している。 =ZEND_ACC_GENERATOR= としてマークする。\n\n#+begin_src c\n  static bool is_generator_compatible_class_type(const zend_string *name) {\n  \treturn zend_string_equals_ci(name, ZSTR_KNOWN(ZEND_STR_TRAVERSABLE))\n  \t\t|| zend_string_equals_literal_ci(name, \"Iterator\")\n  \t\t|| zend_string_equals_literal_ci(name, \"Generator\");\n  }\n\n  /* 中略 */\n\n  static void zend_mark_function_as_generator(void) /* {{{ */\n  {\n  \tif (!CG(active_op_array)->function_name) {\n  \t\tzend_error_noreturn(E_COMPILE_ERROR,\n  \t\t\t\"The \\\"yield\\\" expression can only be used inside a function\");\n  \t}\n\n  \tif (CG(active_op_array)->fn_flags & ZEND_ACC_HAS_RETURN_TYPE) {\n  \t\tconst zend_type return_type = CG(active_op_array)->arg_info[-1].type;\n  \t\tbool valid_type = (ZEND_TYPE_FULL_MASK(return_type) & MAY_BE_OBJECT) != 0;\n  \t\tif (!valid_type) {\n  \t\t\tconst zend_type *single_type;\n  \t\t\tZEND_TYPE_FOREACH(return_type, single_type) {\n  \t\t\t\tif (ZEND_TYPE_HAS_NAME(*single_type)\n  \t\t\t\t\t\t&& is_generator_compatible_class_type(ZEND_TYPE_NAME(*single_type))) {\n  \t\t\t\t\tvalid_type = 1;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t} ZEND_TYPE_FOREACH_END();\n  \t\t}\n\n  \t\tif (!valid_type) {\n  \t\t\tzend_string *str = zend_type_to_string(return_type);\n  \t\t\tzend_error_noreturn(E_COMPILE_ERROR,\n  \t\t\t\t\"Generator return type must be a supertype of Generator, %s given\",\n  \t\t\t\tZSTR_VAL(str));\n  \t\t}\n  \t}\n\n  \tCG(active_op_array)->fn_flags |= ZEND_ACC_GENERATOR;\n  }\n#+end_src\n\nyieldはTracing JITではサポートされていない。\nJITに関しては [[id:C81D01DB-6135-46CD-B491-F35F42002417][PHP8から追加されたJITについて学ぼう!]] に書いている。\n\nhttps://github.com/php/php-src/blob/8b61c49987750b74bee19838c7f7c9fbbf53aace/ext/opcache/jit/zend_jit.c#L2752-L2754\n\n#+begin_src c\n  /* switch through trampoline */\n  case ZEND_YIELD:\n  case ZEND_YIELD_FROM:\n#+end_src\n\n=ZEND_ACC_GENERATOR= flagが立っているものは =ZEND_GENERATOR_CREATE= というOPCODEに割り当てられて処理される。\n\nhttps://github.com/php/php-src/blob/8b61c49987750b74bee19838c7f7c9fbbf53aace/Zend/zend_vm_def.h#L4644-L4720\n\n1. ジェネレーターオブジェクト作成: ジェネレータークラスのオブジェクトを初期化し、通常のVMスタックではなくヒープ上に実行コンテキスト（execute_data）を割り当てて、実行の中断・再開に備える\n2. 実行コンテキスト保存: 現在の実行状態をヒープ上の新しい領域にコピーし、ジェネレーターオブジェクト内に保存して、ZEND_CALL_GENERATORフラグを設定する\n3. 呼び出しフレーム管理: 現在の実行コンテキストを前の実行データに戻し、呼び出し情報に応じて適切なクリーンアップ処理を行ってVMから離脱する\n\n#+begin_src c\n  ZEND_VM_HANDLER(139, ZEND_GENERATOR_CREATE, ANY, ANY)\n  {\n  \tzval *return_value = EX(return_value);\n\n  \tif (EXPECTED(return_value)) {\n  \t\tUSE_OPLINE\n  \t\tzend_generator *generator;\n  \t\tzend_execute_data *gen_execute_data;\n  \t\tuint32_t num_args, used_stack, call_info;\n\n  \t\tSAVE_OPLINE();\n  \t\tobject_init_ex(return_value, zend_ce_generator);\n\n  \t\t/*\n  \t\t ,* Normally the execute_data is allocated on the VM stack (because it does\n  \t\t ,* not actually do any allocation and thus is faster). For generators\n  \t\t ,* though this behavior would be suboptimal, because the (rather large)\n  \t\t ,* structure would have to be copied back and forth every time execution is\n  \t\t ,* suspended or resumed. That's why for generators the execution context\n  \t\t ,* is allocated on heap.\n  \t\t ,*/\n  \t\tnum_args = EX_NUM_ARGS();\n  \t\tif (EXPECTED(num_args <= EX(func)->op_array.num_args)) {\n  \t\t\tused_stack = (ZEND_CALL_FRAME_SLOT + EX(func)->op_array.last_var + EX(func)->op_array.T) * sizeof(zval);\n  \t\t\tgen_execute_data = (zend_execute_data*)emalloc(used_stack);\n  \t\t\tused_stack = (ZEND_CALL_FRAME_SLOT + EX(func)->op_array.last_var) * sizeof(zval);\n  \t\t} else {\n  \t\t\tused_stack = (ZEND_CALL_FRAME_SLOT + num_args + EX(func)->op_array.last_var + EX(func)->op_array.T - EX(func)->op_array.num_args) * sizeof(zval);\n  \t\t\tgen_execute_data = (zend_execute_data*)emalloc(used_stack);\n  \t\t}\n  \t\tmemcpy(gen_execute_data, execute_data, used_stack);\n\n  \t\t/* Save execution context in generator object. */\n  \t\tgenerator = (zend_generator *) Z_OBJ_P(EX(return_value));\n  \t\tgenerator->func = gen_execute_data->func;\n  \t\tgenerator->execute_data = gen_execute_data;\n  \t\tgenerator->frozen_call_stack = NULL;\n  \t\tgenerator->execute_fake.opline = NULL;\n  \t\tgenerator->execute_fake.func = NULL;\n  \t\tgenerator->execute_fake.prev_execute_data = NULL;\n  \t\tZVAL_OBJ(&generator->execute_fake.This, (zend_object *) generator);\n\n  \t\tgen_execute_data->opline = opline;\n  \t\t/* EX(return_value) keeps pointer to zend_object (not a real zval) */\n  \t\tgen_execute_data->return_value = (zval*)generator;\n  \t\tcall_info = Z_TYPE_INFO(EX(This));\n  \t\tif ((call_info & Z_TYPE_MASK) == IS_OBJECT\n  \t\t && (!(call_info & (ZEND_CALL_CLOSURE|ZEND_CALL_RELEASE_THIS))\n  \t\t\t /* Bug #72523 */\n  \t\t\t|| UNEXPECTED(zend_execute_ex != execute_ex))) {\n  \t\t\tZEND_ADD_CALL_FLAG_EX(call_info, ZEND_CALL_RELEASE_THIS);\n  \t\t\tZ_ADDREF(gen_execute_data->This);\n  \t\t}\n  \t\tZEND_ADD_CALL_FLAG_EX(call_info, (ZEND_CALL_TOP_FUNCTION | ZEND_CALL_ALLOCATED | ZEND_CALL_GENERATOR));\n  \t\tZ_TYPE_INFO(gen_execute_data->This) = call_info;\n  \t\tgen_execute_data->prev_execute_data = NULL;\n\n  \t\tcall_info = EX_CALL_INFO();\n  \t\tEG(current_execute_data) = EX(prev_execute_data);\n  \t\tif (EXPECTED(!(call_info & (ZEND_CALL_TOP|ZEND_CALL_ALLOCATED)))) {\n  \t\t\tEG(vm_stack_top) = (zval*)execute_data;\n  \t\t\texecute_data = EX(prev_execute_data);\n  \t\t\tLOAD_NEXT_OPLINE();\n  \t\t\tZEND_VM_LEAVE();\n  \t\t} else if (EXPECTED(!(call_info & ZEND_CALL_TOP))) {\n  \t\t\tzend_execute_data *old_execute_data = execute_data;\n  \t\t\texecute_data = EX(prev_execute_data);\n  \t\t\tzend_vm_stack_free_call_frame_ex(call_info, old_execute_data);\n  \t\t\tLOAD_NEXT_OPLINE();\n  \t\t\tZEND_VM_LEAVE();\n  \t\t} else {\n  \t\t\tZEND_VM_RETURN();\n  \t\t}\n  \t} else {\n  \t\tZEND_VM_DISPATCH_TO_HELPER(zend_leave_helper);\n  \t}\n  }\n#+end_src\n*** Interface\n\nphp docに記述されている。\n\n- generator: https://www.php.net/manual/ja/class.generator.php\n- iterator: https://www.php.net/manual/ja/class.iterator.php\n\n* 得られた結果・所感\n\nyieldの知らなかった使い方や実際にphp-srcがどういう実装になっているのか深堀できてよかった。\n[[id:3A6CCE42-1D89-46CC-8AC4-8358CE2A751C][Laravel LazyCollection in depth]] の理解がより深まった。\n\nDeepWikiで質問をしながら実際のコードを読むというのは体験が良かった。\n[[id:D835E9E4-9229-40B9-97F1-9953C91F74F8][DeepWiki調査メモ]] にも書いたとおり、deepwiki-openを使えばprivate repoでも実現できるので積極的に活用していきたい。\n\nhttps://deepwiki.com/php/php-src\n\n* 今後の展開・検討事項\n\n他にもphp-srcの気になる機能のコードリーディングを気軽にやっていきたい。\n",
  "backlinks": []
}