{
  "id": "29F3BA0F-9585-40EC-B033-E3CDBF62EA13",
  "title": "Common Lispのquoteについて",
  "raw": ":PROPERTIES:\n:ID:       29F3BA0F-9585-40EC-B033-E3CDBF62EA13\n:mtime:    20231217115551\n:ctime:    20221214234305\n:END:\n#+TITLE: Common Lispのquoteについて\n#+AUTHOR: takeokunn\n#+DESCRIPTION: Common Lispのquoteについて\n#+DATE: 2019-03-16T09:00:00+09:00\n#+HUGO_BASE_DIR: ../../\n#+HUGO_SECTION: posts/permanent\n#+HUGO_CATEGORIES: permanent\n#+HUGO_TAGS: common-lisp\n#+HUGO_DRAFT: false\n#+STARTUP: fold\n\nstack overflowに次の2つの質問をした。\n\n- [[https://stackoverflow.com/questions/54868796/cannot-post-slack-webhook-url-in-common-lisp][Cannot post slack webhook url in common lisp]]\n- [[https://stackoverflow.com/questions/55066131/getenv-xxx-is-not-a-lisp-string-or-pointer][(GETENV XXX) is not a Lisp string or pointer Ask Question]]\n\n両方とも ~sds~ という方が答えてくれたのですが、 どうも自分は ~quote~ について理解をしていないことがわかりました。\n\n調べたところ、stack overflowに良さそうな記事があったので翻訳をしてみる。\n\n[[https://stackoverflow.com/questions/134887/when-to-use-or-quote-in-lisp][When to use ' (or quote) in Lisp?]]\n\n--------------\n\n~Question~: quoteっていつ使うの？\n\nLispの入門書を読んだのですが、 ~quote~ や ~'~ 特殊な演算子がどんな挙動をするのか理解できませんでしたし、まだ見たことがありません。\n\nどうでしょうか？\n\n~Short Answer~:\n\nデフォルトの評価ルールを使わず、 =symbol= か =s式= を評価せずに入力された型どおりに関数を渡す。\n\n~Long Answer~: /デフォルトの評価ルール/\n\n通常の関数（後述）が呼び出された時、引数はすべて評価される。\nコードは以下。\n\n#+begin_src lisp\n  (* (+ a 2)\n     3)\n#+end_src\n\n~a~ と ~2~ を順に評価することによって ~(+ a 2)~ を評価する。 シンボル ~a~ の現在束縛されている値を調べ、置き換える。 ~a~ は現在~3~という値が束縛されています。\n\n#+begin_src lisp\n  (let ((a 3))\n    (* (+ a 2)\n       3))\n#+end_src\n\n~(+ 3 2)~ は ~3~ と ~2~ が呼び出され ~5~ を返します。 今、元の形は ~(* 5 3)~ となり、=15= が返されます。\n\n/Explain quote Already!/\n\n大丈夫です。上で見たように、関数の引数はすべて評価されてしまうので、 ~value~ ではなく ~symbol~ を渡したいのであれば、それを評価はしたくありません。\n\n=Lisp symbols can double both as their values, and markers where you in other languages would have used strings, such as keys to hash tables.=\n\nの出番です。LispよりPythonアプリケーションでリソースの割り当てについて作りたいとしましょう。\n\nPythonのアプリケーションはこんな感じ。\n\n#+begin_example\nprint(\"'(\")\nwhile allocating:\n    if random.random() > 0.5:\n        print(f\"(allocate {random.randint(0, 20)})\")\n    else:\n        print(f\"(free {random.randint(0, 20)})\")\n    ...\nprint(\")\")\n#+end_example\n\n出力結果（一部）はこちら。\n\n#+begin_src lisp\n  '((allocate 3)\n    (allocate 7)\n    (free 14)\n    (allocate 19)\n    ...)\n#+end_src\n\nデフォルトの評価ルールが適用されない原因となった引数 ~(\"tick\")~ について述べたことを覚えていますか？\n\nGOOD!\n\n~allocate~ と ~free~ の値が調べられてしまうのはよい挙動ではないです。\n\nLispでは次のようになってほしい。\n\n#+begin_src lisp\n  (dolist (entry allocation-log)\n    (case (first entry)\n      (allocate (plot-allocation (second entry)))\n      (free (plot-free (second entry)))))\n#+end_src\n\n上記のデータに対して、一連の関数呼び出しが行われたはずです。\n\n#+begin_src lisp\n  (plot-allocation 3)\n  (plot-allocation 7)\n  (plot-free 14)\n  (plot-allocation 19)\n#+end_src\n\n/But What About list?/\n\nまぁ、引数を評価したい時もあります。数字と文字列を操作して結果のリストを返す気の利いた関数があるとしましょう。間違ったところから始めましょう。\n\n#+begin_example\n(defun mess-with (number string)\n  '(value-of-number (1+ number) something-with-string (length string)))\n\nLisp> (mess-with 20 \"foo\")\n(VALUE-OF-NUMBER (1+ NUMBER) SOMETHING-WITH-STRING (LENGTH STRING))\n#+end_example\n\n望んだ結果じゃないです！　いくつかの引数を選択的に評価し、別のものは ~symbol~ として残します。\n\n/テイク２/:\n\n#+begin_src lisp\n  (defun mess-with (number string)\n    (list 'value-of-number (1+ number) 'something-with-string (length string)))\n\n  Lisp> (mess-with 20 \"foo\")\n  (VALUE-OF-NUMBER 21 SOMETHING-WITH-STRING 3)\n#+end_src\n\n/ 単なる ~quote~ ではく、 ~backquote~ /\n\nよいですね！　偶然にも、このパターンは（ほとんどの）macroでとても一般的ですので、そのための特別な構文があります。\n\nbackquote:\n\n#+begin_src lisp\n  (defun mess-with (number string)\n    `(value-of-number ,(1+ number) something-with-string ,(length string)))\n#+end_src\n\nquoteを使うのと似ていますが、引数の前にcommaをつけて明示的に評価するoptionがあります。\n\n結果はlistを使用するのと同じですが、macroからコードを生成している場合は、返されるコードのごく一部を評価したいだけですので、backquoteが適しています。\n\n短いリストの場合は、 ~list~ のほうが読みやすくなります。\n\n/Hey, You Forgot About quote!/\n\nquoteは実際何をするのでしょうか？　単にその引数を未評価のまま返します。\n\n最初に通常の関数について言ったことを覚えていますか？\n\n一部の演算子や関数は引数を評価しないようにする必要あることがわかりました。\n\n~if~ のようなものですね、使われないなら ~else~ を評価したくないでしょう。\n~macro~ のような特殊演算子はそのように動作します。\n特別演算子もまた言語の「公理」であり、最小限のルールの集まりであり、それを使用してLispの残りの部分をさまざまな方法で組み合わせることによって実装できます。\n\n~quote~ に戻る。\n\n#+begin_src lisp\n  Lisp> (quote spiffy-symbol)\n  SPIFFY-SYMBOL\n\n  Lisp> 'spiffy-symbol ; ' is just a shorthand (\"reader macro\"), as shown above\n  SPIFFY-SYMBOL\n#+end_src\n\nsbclと比較してください。\n\n#+begin_example\nLisp> spiffy-symbol\ndebugger invoked on a UNBOUND-VARIABLE in thread #<THREAD \"initial thread\" RUNNING   {A69F6A9}>:\n  The variable SPIFFY-SYMBOL is unbound.\n\nType HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.\n\nrestarts (invokable by number or by possibly-abbreviated name):\n  0: [ABORT] Exit debugger, returning to top level.\n\n(SB-INT:SIMPLE-EVAL-IN-LEXENV SPIFFY-SYMBOL #<NULL-LEXENV>)\n0]\n#+end_example\n\nこのスコープには =spiffy-symbol= がないのです！\n\n/Summing Up/\n\n~quote~ 、 ~comma~ 付き ~backquote~、および ~list~ は、値の ~list~ だけでなく、 ~list~ を作成するために使用するツールの一部ですが見たとおり（構造体を定義する必要がない）軽量データ構造として使用できます。\n\n大規模でのプログラミングにすでにしていて、あなたがより多くを学びたい場合は、Lispのを学習への実践的なアプローチのためにピーター・サイベルの本実践Common Lispのをお勧めします。\nLispを使っていると最終的には、パッケージも使い始めるでしょう。\n\n~Ron Garret~ の ~The Common Lisp Package~ の ~The Idiot~ の説明を読むと深く理解できることでしょう。\n\nHappy Hacking!\n",
  "backlinks": []
}