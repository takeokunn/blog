:PROPERTIES:
:ID:       C81D01DB-6135-46CD-B491-F35F42002417
:mtime:    20230115211150 20230115161908 20230115151905 20230115141644 20221222112051
:ctime:    20221222111924
:END:

#+TITLE: PHP8から追加されたJITについて学ぼう!
#+DESCRIPTION: PHPのJITについて書く
#+DATE: 2022-12-22
#+HUGO_BASE_DIR: ../../
#+HUGO_SECTION: posts/permanent
#+HUGO_TAGS: permanent
#+HUGO_DRAFT: true
#+STARTUP: content
#+STARTUP: nohideblocks

* はじめに

2023年現在、PHPは世界中の企業で使われており、最も成功しているプログラミング言語の1つと言っても過言ではないくらい開発者から愛されています。
WikipediaやWordPressもPHP製のプロダクトなので、開発者でなくてもPHPの恩恵を受けている人は多いでしょう。

私も5年以上PHPを用いて開発していますが、日進月歩で進化し続けるPHPにワクワクさせられています。

PHP 8.0が2020年11月にリリースされ、様々な便利な新機能が追加されました。
特に =Match式= は複雑な条件分岐を「式」で書くことができ、より柔軟な記述が可能になります。

高く評価されている新機能の1つに =JIT (ジャストインタイム) コンパイラ= があります。
JITを正しく使うと、条件によってはアプリケーションの1.5倍以上高速化できるということを公式のリリースページに書いてあります。

そもそもJITとは何か、PHP上でどのようにJITが動作しているのかを知れば、アプリケーションの記述を変えずに高速化できるでしょう。

* JITについて

JIT自体の歴史は長く、様々な言語の処理系で実装されています。
JavaScriptの処理系であるV8 EngineもJITを導入することによって大幅な高速化を実現しました。

Ruby 3.1ではYJITが導入されました。
YJITはShopify社製のJIT Compilerで、同社はRailsアプリケーションが =20%~40%= 程度高速化できたという報告をしています。

私の普段使っているEmacsでもJIT Compilerがサポートされて、体感速度として感じられるくらい動作がサクサクになったという実感があります。

PHP、Ruby、JavaScriptのような動的型付け言語は、CやRustのような静的型付け言語よりも実行速度が遅いです。
遅い理由は様ありますが、実行時に字句解析、構文解析、コンパイルをして中間コードを吐き出し、VM上で実行をしているのが原因です。
変数や関数の型情報の多くは実行時に決まり、実行時にVM上で最適化が走るので、どうしても遲くなってしまいます。

高速に実行するアプローチの1つにJIT Compileがあります。
JIT Compileは実行時にマシンコードを吐き出し、キャッシュ上に乗せ、再度実行する時にキャッシュ上のマシンコードを実行するというアプローチです。
マシンコードにすることによって、中間コードにわざわざ変換をしてVM上で変換をする必要がないので高速に動かすことができます。

ちなみに、JITの対比として、C言語のような事前にコンパイルする通常の手法はAOT(Ahead-Of-Time)コンパイルと呼びます。

JIT Compilerの実装は様々ありますが、PHPではDynASMを使っています。
DynASMはLuaでも使われており、既に実績を残しています。

* TODO PHPのJITの基本的な仕組み

2023年1月現在、JITはOPCacheのサブセットとして提供されています。

* インストール方法

JITを利用するにあたって、 =php.ini= のOPCache周りの設定を有効にする必要があります。

#+begin_src ini
  [opcache]
  opcache.enable=1
  opcache.enable_cli=1
#+end_src

JITを以下のように有効にします。

#+begin_src ini
  opcache.jit=tracing ; function
  opcache.jit_buffer_size = 128M
#+end_src

~opcache.jit~ のオプションは大きく分けて =tracing= と =function= の2つがあります。
=tracing= や =function= という文字列はエイリアスであって、4桁の整数値 =CRTO= を直接指定するという高度な使い方もあります。

CRTOはそれぞれ、「C (特定のCPU向けの最適化フラグ)」「R (レジスタの割り付け)」「T (JITを行うトリガ)」「O (最適化レベル)」です。

~opcache.jit_buffer_size~ はコンパイル済みのJITコードを保存する共有メモリの合計サイズです。
ドキュメントには =0= を指定するとJITが無効になるという記述があります。

* JITに適したコード

以下のような =A= と =B= のコードはどちらがJITに適したコードでしょうか？

A:
#+begin_src php
  function A($a, $b)
  {
      return $a + $b;
  }
#+end_src

B:
#+begin_src php
  declare(strict_types=1);

  function B(float $a, float $b): float
  {
      return $a + $b;
  }
#+end_src

答えは =B= です。

JIT Compilerは実行時に型情報を集め、最適化されたマシンコードを吐き出します。

=declare(strict_types=1);= は厳格な型検査モードの指定構文です。
暗黙な型変換を抑えることができます。

PHPは7以降型をより厳格に書けるようになり、PHPStanやPsalmのような静的型検査ができるツールも普及してきています。
それらのツールを使い、厳格に記述すればするほどJIT Compilerの恩恵を受けることができるでしょう。

* JITのデメリットについて

#+begin_quote
一般にJITはコンパイルによるオーバーヘッドを伴うため，場合によっては実行がかえって遅くなってしまう場合もあります．このため，JITでは何らかの手段でスクリプトの実行時にプロファイリングにより時間を要する部分を見つけ出し，部分的にコンパイルを行う手法が用いられます．
#+end_quote

* 終わりに

貴方が関わってるPHPプロジェクトでJITを有効にし、高速化してみては如何でしょうかみたいなポエムを書く。

* 参考記事

- [[https://corsix.github.io/dynasm-doc/index.html][The Unofficial DynASM Documentation]]
- [[https://shopify.engineering/yjit-just-in-time-compiler-cruby][YJIT: Building a New JIT Compiler for CRuby]]
- [[https://php.watch/articles/jit-in-depth][PHP JIT in Depth]]
- [[https://www.slideshare.net/y-uti/jit-70023246][JIT のコードを読んでみた]]
- [[https://keens.github.io/blog/2018/12/01/jitarekore/][JITあれこれ]]
- [[https://blog.tomoya.dev/posts/hello-native-comp-emacs/][ネイティブコンパイルEmacsの登場]]
- [[https://tech.griphone.co.jp/2021/12/23/php8jit/][PHP8でのJIT導入の背景について調べてみた]]
