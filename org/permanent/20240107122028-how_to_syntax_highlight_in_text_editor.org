:PROPERTIES:
:ID:       3249F27E-9CE1-4ADC-9B34-607C7DCEC60D
:END:
#+TITLE: テキストエディタがPHPをシンタックスハイライトする仕組みとモダンテキストエディタ事情について
#+AUTHOR: takeokunn
#+DESCRIPTION: description
#+DATE: 2024-01-07T12:20:39+0900
#+HUGO_BASE_DIR: ../../
#+HUGO_CATEGORIES: permanent
#+HUGO_SECTION: posts/permanent
#+HUGO_TAGS: fleeting
#+HUGO_DRAFT: true
#+STARTUP: content
#+STARTUP: nohideblocks
* 注意

この記事はPHPerKaigi 2024のパンフレット記事です。
書面での掲載につきハイパーリンクがないことをご了承ください。

https://fortee.jp/phperkaigi-2024/proposal/161b2ec9-c279-4336-8e17-1aa054dacae9

* Introduction

プログラミング言語は日進月歩で進化し続けています。
処理系のパフォーマンス改善、既存のバグ修正、挙動の変更などさまざまな変更が入るが、ユーザーにとって一番影響があるのは「新規の構文追加」ではないでしょうか？
PHPの場合PHP 8.0以降にmatch式やenum構文は直近5年以内に追加されたものです。
PHPに限らずほか言語のRFCでも新規の構文が提案されている例は枚挙に暇がありません。Goのジェネリクスなどもその一例です。

言語レベルで新規の構文が追加された時、テキストエディタでも正しく解釈できるように対応する必要があります。
それはオープンソースのテキストエディタだろうと商用エディタだろうと区別はありません。
そもそもテキストエディタはどのように構文を解釈してハイライトしてくれているのか、tree-sitterなどの最近のテキストエディタ事情も踏まえて解説していきます。

なお私は熱狂的なEmacsユーザーでありEmacsのPHP Pluginであるphp-modeのオーナー権限もあるので、Emacsひいきな解説になってしまうのはご了承ください。

* シンタックスハイライトとは

- シンタックスハイライトとは
  - 構文に色をつけてくれるもの
    - 変数やnewのようなキーワード、functionやclassなど
  - Wikipediaによるとシンタックスカラリング・構文着色とも言うらしい
- メリット
  - テキストの可読性を向上させ文脈をより明瞭にする
  - 記述ミスや括弧の対応のミスなどを防ぐことができる
- デメリット
  - 流し読みがしやすくなるので、プログラマーはコード全体を理解しようとはしなくなる（by wikipedia）
- カラーテーマごとに配色が違う
  - 世の中には無数のカラーテーマがある
  - 筆者はDraculaやSublime Textのdefault themeのmonokaiが好き
- 言語の数だけシンタックスハイライトがある
  - 言語ごとに構文が違う
  - 似ている言語は上書きするように記述している
    - PHPはC言語に似ている
    - 昔php-modeはjava-modeを継承して実装していた

* シンタックスハイライトの大まかなしくみ

- テキストエディタによって実装が違う
- 凡そ2つに大別できる
  - 正規表現ベース
  - ASTベース
- 正規表現ベースは古いテキストエディタでよく使われている
  - EmacsやVimはそう
  - それぞれのテキストエディタごとに実装されている
- ASTベースは比較的新しいテキストエディタで実装されている
  - 今は亡きAtomが発祥
  - VSCodeがそう
  - NeoVimやEmacsは最近本体に組み込れた
- ASTベースのツールはほぼTree-Sitterが一強
  - Rust製で非常に高速で挙動する
  - テキストエディタに依存しない形で実装されている
- 難しいところ
  - 常にユーザーが入力し続けるので構文が確定しない
  - 1入力ごとにハイライトする必要がある
    - 高速で動かす必要がある
  - 1言語で複数言語を表現する場合難易度が上がる
    - VueJsはHTML/CSS/JavaScriptを記述できる
    - PHPもHyperText PreprocessorなのでHTMLを記述できる

* 正規表現によるシンタックスハイライト

- キーワードは直接色を付ける
- 正規表現によって構文を定義する
  - =$= の後は確実に変数
  - =function= の後は確実に関数名になり、その後の括弧は関数の引数になる
  - =//= 直後はすべてコメントになる
- 1言語内に複数言語の場合
  - Emacsの場合はカーソル位置の対象の言語に切り替える処理をしている
- メリット
  - 低メモリで高速で動く
    - 1990年代のPCでも動く
  - 構文を確定しなくてもハイライトできる
- デメリット
  - 正規表現の難易度が高い
  - 正規表現エンジンの実装依存になる
    - Emacsの場合は正規表現の先読みが使えない
    - しょうがないからカーソルを擬似的に動かすことによって先読みを実現している
  - 各テキストエディタごとに実装する必要がある
    - PHPのような比較的シンプルな構文の言語はまだ良い
    - C++のような複雑怪奇な構文をハイライトするには正規表現では厳しい
      - EmacsのCっぽい構文をハイライトするcc-modeは明らかに天才が作ったが凡人の我々には到底理解できない実装になっている
    - 世の中にプログラミング言語は増えているのにEmacsのようなユーザー数が減っているエディタはすべての言語に対応するのは厳しい
      - PHPに関しては私やtadsanが対応しているので我々の目が黒いうちは対応していくつもり

* ASTベースによるシンタックスハイライト

- Tree-Sitterが一強なのでTree-Sitterを元に書く
- Tree-SitterはRust/Cで書かれていて特定のエディタに依存しない実装になっている
  - LSPやDAPと似ている
- それぞれの言語ごとにgrammarが提供されている
  - phpの場合はtree-sitter-php
- 各エディタはTree-SitterのC部分のwrapperを作りエディタ内で使えるようにしている
- キーワードは直接色を付ける
- 構文はJavaScriptベースの独自DSLで記述している
  - yaccのような記述
  - https://github.com/tree-sitter/tree-sitter-php/blob/マスタ/common/define-grammar.js
- ソースコードを渡すとs式を掃き出す
- 構文エラーの場合の処理がはっきりしている
  - 構文の優先準備を記述できる
  - エラーになった箇所のみエラーという判定になる
- 1言語内に複数言語の場合
  - 特定のくくり内は =tree-sitter-{lang}= を実行するようなしくみ
- メリット
  - メジャーな言語はだいたいサポートされている
  - エディタごとの実装をする必要ないのでメンテナンスされる可能性が高い
- デメリット
  - 構文が確定するまで色がつかない
  - 毎回ASTを作る必要があるので正規表現と比べて低速
    - とはいえTree-Sitterは高速で動くし、2024年の標準的なコンピュータでは気にならない程度
  - テキストエディタ本体はTree-Sitterのサポートをし続けないといけない
    - 普通のユーザーが触れない部分なので何かあった時に対応しつらい

* 終わりに

- 言語の進化にエディタも追従する必要がある
- テキストエディタのことが好きなので頑張ってメンテナンスしてきたい
