{
  "id": "F461F483-2C99-4BC1-B122-9409545C5374",
  "title": "JavaScriptのthisについて",
  "raw": ":PROPERTIES:\n:ID:       F461F483-2C99-4BC1-B122-9409545C5374\n:mtime:    20231204003036\n:ctime:    20221215021444\n:END:\n#+TITLE: JavaScriptのthisについて\n#+AUTHOR: takeokunn\n#+DESCRIPTION: JavaScriptのthisについて\n#+DATE: 2019-07-01T09:00:00+09:00\n#+HUGO_BASE_DIR: ../../\n#+HUGO_SECTION: posts/permanent\n#+HUGO_CATEGORIES: permanent\n#+HUGO_TAGS: javascript\n#+HUGO_DRAFT: false\n#+STARTUP: fold\n\n会社のインターン生にJavaScriptの ~this~ についてドヤ顔で説明してたら、間違って理解していたことがわかってしまった。\n\n同僚と ~this~ がどのような挙動をするのかで盛り上がって楽しかった。\n\n[[https://qiita.com/valley/items/62c9480368f1409c90ae][【JS】ああthisよ。君は今、どのオブジェクトなのか（練習問題あり）]]\n\n同僚の ~@valley~ 氏の記事がおおよそすべてを説明してくれているが、この記事では自分の言葉で ~this~ について説明する。\n\n--------------\n\n元記事ではブラウザで実行していたが、この記事では ~nodejs~ で実行するので ~window -> global~ となる。\n\n#+begin_quote\n結局そのscopeが評価された時のcontextがthisになる。\n関数やオブジェクトが評価されるタイミングはいつなの？ってことを考えればあとは自然とthisを導き出せる。\nfunctionが評価されるタイミングとlambdaが評価されるタイミングが違うというだけ。\n#+end_quote\n\nたとえば、次のようなスクリプトがある。\n\n~func1~ の関数が評価されるのは実行時なので ~{}~ だが、 ~func2~ の関数が評価されるのはコンパイル時なので ~global~ になる。\n\n#+begin_src js\n  const func1 = () => {\n      console.log(this);\n  };\n\n  const func2 = function () {\n      console.log(this);\n  };\n\n  console.log(func1); // {}\n  console.log(func2); // global\n#+end_src\n\nファイル分割した場合はどうなるだろうか。次のようなコードを書いてみた。\n\n~test.js~:\n\n#+begin_src js\n  const { func1, func2 } = require(\"./test1.js\");\n\n  console.log(this.aaa); // undefined\n\n  func1(); // { aaa: 'bbb' }\n  fund2(); // global\n#+end_src\n\n~test1.js~:\n\n#+begin_src js\n  this.aaa = 'bbb';\n\n  const func1 = () => {\n      console.log(this);\n  };\n\n  const func2 = function () {\n      console.log(this);\n  };\n\n  module.exports = { func1, func2 };\n#+end_src\n\n--------------\n\n教えるのも勉強なるし、こうやって深堀するとさらに詳しく慣れて楽しい。\n",
  "backlinks": []
}