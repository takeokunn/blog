<!doctype html><html lang=ja-jp dir=ltr prefix="og: https://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=Hatena::Bookmark content="nocomment"><title itemprop=name>Emacsを世界最速級で起動する方法 | takeokunn's blog</title><meta property="og:title" content="Emacsを世界最速級で起動する方法 | takeokunn's blog"><meta name=twitter:title content="Emacsを世界最速級で起動する方法 | takeokunn's blog"><meta itemprop=name content="Emacsを世界最速級で起動する方法 | takeokunn's blog"><meta name=application-name content="Emacsを世界最速級で起動する方法 | takeokunn's blog"><meta property="og:site_name" content><meta name=description content="Emacs Advent Calendar 2022 19日目です。
Vim Advent Calendar 2022 3日目の 爆速で起動する Neovim を作る に触発されて、「自分もEmacs版を書くぞ！」ということで書いていきます。
なお、VimとEmacsの比較をし易くするためになるべく文章の構成を寄せて書くことをご了承ください。
始めに 「Emacsを高速に起動する」ということに対して、多くのEmacsユーザーは興味がありません。 本来Emacsというのは常に起動し続けるものであり、必要に応じてEmacs Lispを適用し、テキストエディタをカスタマイズしていくものです。 現に「"><meta itemprop=description content="Emacs Advent Calendar 2022 19日目です。
Vim Advent Calendar 2022 3日目の 爆速で起動する Neovim を作る に触発されて、「自分もEmacs版を書くぞ！」ということで書いていきます。
なお、VimとEmacsの比較をし易くするためになるべく文章の構成を寄せて書くことをご了承ください。
始めに 「Emacsを高速に起動する」ということに対して、多くのEmacsユーザーは興味がありません。 本来Emacsというのは常に起動し続けるものであり、必要に応じてEmacs Lispを適用し、テキストエディタをカスタマイズしていくものです。 現に「"><meta property="og:description" content="Emacs Advent Calendar 2022 19日目です。
Vim Advent Calendar 2022 3日目の 爆速で起動する Neovim を作る に触発されて、「自分もEmacs版を書くぞ！」ということで書いていきます。
なお、VimとEmacsの比較をし易くするためになるべく文章の構成を寄せて書くことをご了承ください。
始めに 「Emacsを高速に起動する」ということに対して、多くのEmacsユーザーは興味がありません。 本来Emacsというのは常に起動し続けるものであり、必要に応じてEmacs Lispを適用し、テキストエディタをカスタマイズしていくものです。 現に「"><meta name=twitter:description content="Emacs Advent Calendar 2022 19日目です。
Vim Advent Calendar 2022 3日目の 爆速で起動する Neovim を作る に触発されて、「自分もEmacs版を書くぞ！」ということで書いていきます。
なお、VimとEmacsの比較をし易くするためになるべく文章の構成を寄せて書くことをご了承ください。
始めに 「Emacsを高速に起動する」ということに対して、多くのEmacsユーザーは興味がありません。 本来Emacsというのは常に起動し続けるものであり、必要に応じてEmacs Lispを適用し、テキストエディタをカスタマイズしていくものです。 現に「"><meta property="og:locale" content="ja-jp"><meta name=language content="ja-jp"><link rel=alternate hreflang=ja-jp href=https://www.takeokunn.org/posts/permanent/20221217132815-emacs_more_faster/ title=Japanese><meta property="og:type" content="article"><meta property="og:article:published_time" content="2022-12-17T09:00:00+09:00"><meta property="article:published_time" content="2022-12-17T09:00:00+09:00"><meta property="og:url" content="https://www.takeokunn.org/posts/permanent/20221217132815-emacs_more_faster/"><meta itemprop=image content="https://www.takeokunn.org/ogp/20221217132815-emacs_more_faster.png"><meta property="og:image" content="https://www.takeokunn.org/ogp/20221217132815-emacs_more_faster.png"><meta name=twitter:image content="https://www.takeokunn.org/ogp/20221217132815-emacs_more_faster.png"><meta name=twitter:image:src content="https://www.takeokunn.org/ogp/20221217132815-emacs_more_faster.png"><meta name=twitter:card content="summary_large_image"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Emacsを世界最速級で起動する方法","author":{"@type":"Person","name":""},"datePublished":"2022-12-17T09:00:00\u002b09:00","description":"Emacs Advent Calendar 2022 19日目です。\nVim Advent Calendar 2022 3日目の 爆速で起動する Neovim を作る に触発されて、「自分もEmacs版を書くぞ！」ということで書いていきます。\nなお、VimとEmacsの比較をし易くするためになるべく文章の構成を寄せて書くことをご了承ください。\n始めに 「Emacsを高速に起動する」ということに対して、多くのEmacsユーザーは興味がありません。 本来Emacsというのは常に起動し続けるものであり、必要に応じてEmacs Lispを適用し、テキストエディタをカスタマイズしていくものです。 現に「","wordCount":1208,"mainEntityOfPage":"True","dateModified":"2022-12-17T09:00:00\u002b09:00","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"takeokunn\u0027s blog"}}</script><link rel=canonical href=https://www.takeokunn.org/posts/permanent/20221217132815-emacs_more_faster/><link href=/posts/permanent/20221217132815-emacs_more_faster/ rel=alternate type=application/rss+xml title="takeokunn's blog"><link href=/posts/permanent/20221217132815-emacs_more_faster/ rel=feed type=application/rss+xml title="takeokunn's blog"><link href=/style.min.71c11b16c107f1031ce1f17c8e2fef21394bb486a285ca4d0a69d5c311e607d5.css rel=stylesheet><link href=/code-highlight.min.ca0d5ee203390cf1a8d6b0b0204024fa2424a020fd6554c7df0c2a572e19c583.css rel=stylesheet><link rel="shortcut icon" href=/favicon.ico></head><body class=notransition aria-live=polite><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=https://www.takeokunn.org/ class=logo aria-label=Home><svg width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home" aria-hidden="true" focusable="false"><title>Home</title><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
</a><input type=checkbox id=menu-trigger class=menu-trigger aria-expanded=false aria-controls=site-menu>
<label for=menu-trigger aria-label="Toggle menu"><span class=menu-icon aria-hidden=true><svg width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14" aria-hidden="true" focusable="false"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger id=site-menu><label for=menu-trigger class=menu-close-button aria-label="Close menu">&#215;</label><ul class=trigger-container role=menu><li role=none><a class=menu-link href=/ role=menuitem>Home</a></li><li role=none><a class="menu-link active" href=/posts/ role=menuitem aria-current=page>Posts</a></li><li role=none><a class=menu-link href=/graph/ role=menuitem>Graph</a></li></ul></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article role=article><header class=header><h1 class=header-title>Emacsを世界最速級で起動する方法</h1><div class=post-meta><time datetime=2022.12.17 itemprop=datePublished aria-label="Published on 2022.12.17">2022.12.17</time></div><ul class=tags aria-label="Post tags"><li><a href=/tags/emacs aria-label="View all posts with tag: emacs">emacs</a></li></ul></header><details class=toc><summary aria-label="Toggle Table of Contents"><b>Table of Contents</b></summary><nav id=TableOfContents><ul><li><a href=#始めに>始めに</a></li><li><a href=#前提>前提</a><ul><li><a href=#環境>環境</a></li><li><a href=#設定について>設定について</a></li></ul></li><li><a href=#起動速度の測り方>起動速度の測り方</a><ul><li><a href=#そもそも起動速度とはなんなのか>そもそも起動速度とはなんなのか</a></li><li><a href=#計測方法>計測方法</a></li><li><a href=#評価のし方>評価のし方</a></li></ul></li><li><a href=#この記事で達成する目標>この記事で達成する目標</a></li><li><a href=#具体的なアプローチ方法>具体的なアプローチ方法</a><ul><li><a href=#パッケージ管理ツールについて>パッケージ管理ツールについて</a></li><li><a href=#nativecomp>NativeComp</a><ul><li><a href=#emacsをfull-nativecompでbuildする>EmacsをFull NativeCompでBuildする</a></li><li><a href=#nativecompした結果のファイル-eln-が優先的に読み込まれる>NativeCompした結果のファイル（eln）が優先的に読み込まれる</a></li><li><a href=#init-dot-elとearly-init-dot-elをbyte-compileする>init.elとearly-init.elをbyte-compileする</a></li><li><a href=#nativecompの設定>NativeCompの設定</a></li><li><a href=#init-dot-elとearly-init-dot-elをnativecompする>init.elとearly-init.elをNativeCompする</a></li></ul></li><li><a href=#early-init-dot-elについて>early-init.elについて</a></li><li><a href=#compile時処理>Compile時処理</a><ul><li><a href=#el-get-bundleをeval-when-compile時に落とす>el-get-bundleをeval-when-compile時に落とす</a></li><li><a href=#環境ごとのif文をmacroで定義する>環境ごとのif文をmacroで定義する</a></li></ul></li><li><a href=#ライブラリ周りの読み込み>ライブラリ周りの読み込み</a><ul><li><a href=#async-loadをする>async loadをする</a></li><li><a href=#autoload-with-eval-after-loadを活用する>autoload/with-eval-after-loadを活用する</a></li></ul></li><li><a href=#設定>設定</a><ul><li><a href=#magic-file-name-を一時的に無効にする>Magic File Name を一時的に無効にする</a></li><li><a href=#gcの設定>GCの設定</a></li></ul></li></ul></li><li><a href=#その他>その他</a><ul><li><a href=#add-to-listについて>add-to-listについて</a></li><li><a href=#porテーブル-dumperについて>Porテーブル Dumperについて</a></li><li><a href=#lsp-modeのperformanceについて>lsp-modeのperformanceについて</a></li><li><a href=#el-getのpackageもnativecompする>el-getのpackageもNativeCompする</a></li></ul></li><li><a href=#終わりに>終わりに</a></li></ul></nav></details><div class=page-content><p><a href=https://qiita.com/advent-calendar/2022/emacs>Emacs Advent Calendar 2022</a> 19日目です。</p><p><a href=https://qiita.com/advent-calendar/2022/vim>Vim Advent Calendar 2022</a> 3日目の <a href=https://qiita.com/delphinus/items/fb905e452b2de72f1a0f>爆速で起動する Neovim を作る</a> に触発されて、「自分もEmacs版を書くぞ！」ということで書いていきます。</p><p>なお、VimとEmacsの比較をし易くするためになるべく文章の構成を寄せて書くことをご了承ください。</p><h2 id=始めに>始めに</h2><p>「Emacsを高速に起動する」ということに対して、多くのEmacsユーザーは興味がありません。
本来Emacsというのは常に起動し続けるものであり、必要に応じてEmacs Lispを適用し、テキストエディタをカスタマイズしていくものです。
現に「Emacs, 起動、 高速化」と検索すると、「4000msを1000msにした」のような秒単位での高速化の記事ばかりみつかります。</p><p>もしあなたが設定を変えずに手軽に高速に起動したい場合は <code>emacs --daemon</code> でdaemonを立ち上げ、 <code>emacsclient</code> でつなぐようにすればよいでしょう。
私は他人のdotfilesを読むのが趣味なのですが、多くのEmacsユーザーは <code>EDITOR=emacsclient</code> と設定しています。</p><p>また、起動時間のみを考慮するなら <code>~/.emacs.d/init.el</code> を削除して素で起動すればよいでしょう。
そうなると純粋にマシンスペックの勝負になります。
Emacsは素の状態でも十分魅力的な機能を多数盛り込まれているが、カスタマイズしてこそ真価を発揮するエディタなのでアプローチとしてはイマイチでしょう。</p><p>この記事を読む前に <a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4>Emacs の起動時間を"&ldquo;詰める&rdquo;"</a> を熟読することを推奨しています。
特に次のChapterは非常に有益なテクニックが詰め込まれており、大幅な速度改善を見込めます。</p><ul><li><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/abb04ff2351b3564a1a0>autoload と with-eval-after-load</a></li><li><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/c47f8eb7cd547b95ba91>擬似非同期ロードによる"待たされ感"改善</a></li><li><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4>その他のテクニック：不要な処理を省くハックたち</a></li></ul><p>本のあらすじにも書いてあるとおり、Emacs自体にすでに大量のファイルがある状態で高速に起動する時点で自分の設定を見直さなければならないことは明白でしょう。</p><blockquote><p>しかし、考えてみれば Emacs には 1000 以上の Emacs Lisp ファイルが初めから同梱されているわけで、そこに数十のプラグインを足しただけで爆裂に遅くなるのは、なにか設定にも問題がある気がします。</p></blockquote><p>詳細は後述しますが、現在の私のEmacsは15〜25ms程度で起動をします。
一切設定を読まずに素で起動するコマンド <code>emacs -Q</code> で起動させると2ms程度です。
まだまだ高速に起動させる余地はありますが、「高速に起動させることができている」と自負しても問題ないでしょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Emacs booting time: 20 [msec] = ‘emacs-init-time’.
</span></span><span style=display:flex><span>Loading init files: 10 [msec], of which 1 [msec] for ‘after-init-hook’.
</span></span></code></pre></div><h2 id=前提>前提</h2><h3 id=環境>環境</h3><p>2022年12月現在、 <code>Macbook Pro 16-inch, 2019</code> の標準モデルを使っています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ neofetch
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;c.          take@obaranoMacBook-Pro.local
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                 ,xNMM.          -----------------------------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>               .OMMMMo           OS: macOS 13.1 22C65 x86_64
</span></span></span><span style=display:flex><span><span style=color:#e6db74>               OMMM0,            Host: MacBookPro16,1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     .;loddo:&#39;</span> loolloddol;.      Kernel: 22.2.0
</span></span><span style=display:flex><span>   cKMMMMMMMMMMNWMMMMMMMMMM0:    Uptime: <span style=color:#ae81ff>1</span> day, <span style=color:#ae81ff>18</span> hours, <span style=color:#ae81ff>29</span> mins
</span></span><span style=display:flex><span> .KMMMMMMMMMMMMMMMMMMMMMMMWd.    Packages: <span style=color:#ae81ff>347</span> <span style=color:#f92672>(</span>brew<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> XMMMMMMMMMMMMMMMMMMMMMMMX.      Shell: fish 3.5.1
</span></span><span style=display:flex><span>;MMMMMMMMMMMMMMMMMMMMMMMM:       Resolution: 1792x1120@2x
</span></span><span style=display:flex><span>:MMMMMMMMMMMMMMMMMMMMMMMM:       DE: Aqua
</span></span><span style=display:flex><span>.MMMMMMMMMMMMMMMMMMMMMMMMX.      WM: Quartz Compositor
</span></span><span style=display:flex><span> kMMMMMMMMMMMMMMMMMMMMMMMMWd.    WM Theme: Blue <span style=color:#f92672>(</span>Dark<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> .XMMMMMMMMMMMMMMMMMMMMMMMMMMk   Terminal: tmux
</span></span><span style=display:flex><span>  .XMMMMMMMMMMMMMMMMMMMMMMMMK.   CPU: Intel i7-9750H <span style=color:#f92672>(</span>12<span style=color:#f92672>)</span> @ 2.60GHz
</span></span><span style=display:flex><span>    kMMMMMMMMMMMMMMMMMMMMMMd     GPU: Intel UHD Graphics 630, AMD Radeon Pro 5300M
</span></span><span style=display:flex><span>     ;KMMMMMMMWXXWMMMMMMMk.      Memory: 9716MiB / 16384MiB
</span></span><span style=display:flex><span>       .cooc,.    .,coo:.
</span></span></code></pre></div><p>Emacsのversionは <code>30.0.50</code> です。
日々HEAD buildをしているので最新のversionとは微妙に差異がありますが、起動速度にはそこまで大きな差が出ないでしょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ emacs -version
</span></span><span style=display:flex><span>GNU Emacs 30.0.50
</span></span><span style=display:flex><span>Development version 6a390fd42ec4 on master branch; build date 2022-12-17.
</span></span><span style=display:flex><span>Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> <span style=color:#ae81ff>2022</span> Free Software Foundation, Inc.
</span></span><span style=display:flex><span>GNU Emacs comes with ABSOLUTELY NO WARRANTY.
</span></span><span style=display:flex><span>You may redistribute copies of GNU Emacs
</span></span><span style=display:flex><span>under the terms of the GNU General Public License.
</span></span><span style=display:flex><span>For more information about these matters, see the file named COPYING.
</span></span></code></pre></div><h3 id=設定について>設定について</h3><ul><li><a href=https://github.com/takeokunn/.emacs.d>takeokunn/.emacs.d</a></li><li><a href=https://emacs.takeokunn.org/>init.el</a></li><li><a href=https://emacs.takeokunn.org/early-init>early-init</a></li></ul><p>2022年現在、 <code>init.el</code> と <code>early-init.el</code> は6800行（空白を除くと5800行）程度あります。
設定を別ファイルに切り分けたりしておらず、 <code>init.el</code> 1つで管理をしています。</p><p>すべての設定を <code>org-mode</code> で管理しており、GitHub ActionsでbuildをしGitHub Pagesにhostingしています。</p><p><code>el-get</code> で導入しているpackage数は384個です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ls -l ~/.emacs.d/el-get | wc -l
</span></span><span style=display:flex><span>     <span style=color:#ae81ff>384</span>
</span></span></code></pre></div><h2 id=起動速度の測り方>起動速度の測り方</h2><h3 id=そもそも起動速度とはなんなのか>そもそも起動速度とはなんなのか</h3><p>Emacsはざっくり次のような起動プロセスを踏みます。</p><ul><li>boot処理（C言語）</li><li><a href=https://github.com/emacs-mirror/emacs/blob/master/lisp/startup.el>lisp/startup.el</a> が読み込まれる</li><li><a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L577-L850>normal-top-level</a> が実行される</li><li><a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1125-L1639>command-line</a> が実行される</li><li><code>~/.emacs.d/early-init.el</code> が読み込まれる<ul><li><a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1358-L1367>https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1358-L1367</a></li></ul></li><li><code>~/.emacs.d/init.el</code> が読み込まれる<ul><li><a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1482-L1507>https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1482-L1507</a></li></ul></li></ul><p>Emacs自体にpatchを当てない限り、 <code>~/.emacs.d/early-init.el</code> より前には手が出せません。
<a href=https://github.com/emacs-mirror/emacs/blob/master/lisp/proced.el>lisp/proced.el</a> のような既存のEmacs Lispファイルは<a href=https://www.emacswiki.org/emacs/DumpingEmacs>portable dumper</a>ですでに実行可能なbinaryに出力されており、fileをloadすることなく実行されているようです。</p><p>Emacsのbuild時に自分の <code>init.el</code> を読み込ませて <code>pdump</code> を生成するのが真の最速であり、5ms以内での起動を期待できます。
たとえ記述がほぼないとしても <code>init.el</code> と <code>early-init.el</code> を読み込み実行するというのは重いもので、File I/Oというのは重いものだと実感させられました。
しかし、それではEmacsのカスタマイズ性というのを殺すことになるので今回は含めないこととします。</p><h3 id=計測方法>計測方法</h3><p><code>init.el</code> に次のようなコードを記述します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(defconst my/before-load-init-time (<span style=color:#a6e22e>current-time</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;;###autoload</span>
</span></span><span style=display:flex><span>(defun my/load-init-time ()
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;Loading time of user init files including time for </span><span style=color:#e6db74>`after-init-hook&#39;</span><span style=color:#e6db74>.&#34;</span>
</span></span><span style=display:flex><span>  (let ((time1 (<span style=color:#a6e22e>float-time</span>
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>time-subtract</span> after-init-time my/before-load-init-time)))
</span></span><span style=display:flex><span>        (time2 (<span style=color:#a6e22e>float-time</span>
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>time-subtract</span> (<span style=color:#a6e22e>current-time</span>) my/before-load-init-time))))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>message</span> (<span style=color:#a6e22e>concat</span> <span style=color:#e6db74>&#34;Loading init files: %.0f [msec], &#34;</span>
</span></span><span style=display:flex><span>                     <span style=color:#e6db74>&#34;of which %.f [msec] for </span><span style=color:#e6db74>`after-init-hook&#39;</span><span style=color:#e6db74>.&#34;</span>)
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>*</span> <span style=color:#ae81ff>1000</span> time1) (<span style=color:#a6e22e>*</span> <span style=color:#ae81ff>1000</span> (<span style=color:#a6e22e>-</span> time2 time1)))))
</span></span><span style=display:flex><span>(add-hook <span style=color:#e6db74>&#39;after-init-hook</span> <span style=color:#a6e22e>#&#39;</span>my/load-init-time <span style=color:#66d9ef>t</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(defvar my/tick-previous-time my/before-load-init-time)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;;###autoload</span>
</span></span><span style=display:flex><span>(defun my/tick-init-time (msg)
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;Tick boot sequence at loading MSG.&#34;</span>
</span></span><span style=display:flex><span>  (when my/loading-profile-p
</span></span><span style=display:flex><span>    (let ((ctime (<span style=color:#a6e22e>current-time</span>)))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>message</span> <span style=color:#e6db74>&#34;---- %5.2f[ms] %s&#34;</span>
</span></span><span style=display:flex><span>               (<span style=color:#a6e22e>*</span> <span style=color:#ae81ff>1000</span> (<span style=color:#a6e22e>float-time</span>
</span></span><span style=display:flex><span>                        (<span style=color:#a6e22e>time-subtract</span> ctime my/tick-previous-time)))
</span></span><span style=display:flex><span>               msg)
</span></span><span style=display:flex><span>      (setq my/tick-previous-time ctime))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(defun my/emacs-init-time ()
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;Emacs booting time in msec.&#34;</span>
</span></span><span style=display:flex><span>  (interactive)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>message</span> <span style=color:#e6db74>&#34;Emacs booting time: %.0f [msec] = </span><span style=color:#e6db74>`emacs-init-time&#39;</span><span style=color:#e6db74>.&#34;</span>
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>*</span> <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>              (<span style=color:#a6e22e>float-time</span> (<span style=color:#a6e22e>time-subtract</span>
</span></span><span style=display:flex><span>                           after-init-time
</span></span><span style=display:flex><span>                           before-init-time)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(add-hook <span style=color:#e6db74>&#39;after-init-hook</span> <span style=color:#a6e22e>#&#39;</span>my/emacs-init-time)
</span></span></code></pre></div><p>参考記事はこちら。</p><ul><li><a href=https://memo.sugyan.com/entry/20120120/1327037494>起動時間を計測する 改訂版 - すぎゃーんメモ</a></li><li><a href=https://github.com/takaxp/emacs.d/blob/master/init.org#241-emacs-%E8%B5%B7%E5%8B%95%E6%99%82%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E9%A0%86>init.org - takaxp/emacs.d</a></li></ul><p>そうすると起動後 <code>*Minibuffer*</code> に起動時間の出力がされるはずです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Emacs booting time: 20 [msec] = ‘emacs-init-time’.
</span></span><span style=display:flex><span>Loading init files: 10 [msec], of which 1 [msec] for ‘after-init-hook’.
</span></span></code></pre></div><h3 id=評価のし方>評価のし方</h3><p>高速化する上で重要なのは、評価指標をマシンスペックに依存しない形で評価をすることでしょう。</p><p>次のような <code>init.el</code> を作成すれば、起動時にどのような処理が行われているのか知ることができます。</p><p><code>init.el</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(require <span style=color:#e6db74>&#39;profiler</span>)
</span></span><span style=display:flex><span>(profiler-start <span style=color:#e6db74>&#39;cpu</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;; --------- 処理中略 ---------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(profiler-report)
</span></span><span style=display:flex><span>(profiler-stop)
</span></span></code></pre></div><p>上記のような、処理が空の <code>init.el</code> を用意して起動すると次のようなreport bufferが起動するでしょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Samples    %   Function
</span></span><span style=display:flex><span>      7 100% - normal-top-level
</span></span><span style=display:flex><span>      7 100%  - command-line
</span></span><span style=display:flex><span>      7 100%   - startup--load-user-init-file
</span></span><span style=display:flex><span>      7 100%    - load
</span></span><span style=display:flex><span>      7 100%       byte-code
</span></span><span style=display:flex><span>      0   0% + ...
</span></span></code></pre></div><p>多少ブレがあるものの、自分の <code>init.el</code> で実行をするとSamples数が15以内で起動します。
Sample数が素に近ければ近いほど、高速に動いているといえます。</p><h2 id=この記事で達成する目標>この記事で達成する目標</h2><p>皆さんのEmacsの起動速度はどうでしょうか？
私の感覚になりますが、だいたい次のように分類できるでしょう。</p><ul><li>5000ms以上<ul><li>だいぶ遅い</li><li>外部への通信（パッケージの更新等）が多数走ってしまっている可能性が高い</li></ul></li><li>1000ms 〜 5000ms<ul><li>一般的な速度</li><li>だいたいのEmacsユーザーはこの辺だろう</li><li>パッケージ管理ツールを普通に使って普通に設定しているとこのくらい</li></ul></li><li>100ms 〜 1000ms<ul><li>パッケージ管理ツールで高速化をするとだいたいこの辺になる</li><li>そこそこ頑張る必要がある</li></ul></li><li>100ms以下<ul><li>すべての設定をパッケージ管理ツールを使わずに素で書いているか、高速化にこだわった設定をしている</li><li>かなり頑張る必要がある</li><li><code>EDITOR=emacs</code> 設定するのを視野に入れられる</li></ul></li></ul><p><a href=https://qiita.com/delphinus/items/fb905e452b2de72f1a0f#3-%E3%81%93%E3%81%AE%E8%A8%98%E4%BA%8B%E3%81%A7%E9%81%94%E6%88%90%E3%81%99%E3%82%8B%E7%9B%AE%E6%A8%99>NeoVimの場合</a>はこちら。
Neovimでは「50ms以下」から「500ms以上」を話題にしているので明らかにEmacsはスタート地点が遅い。</p><p>この記事では当然100ms以下を目指している。</p><h2 id=具体的なアプローチ方法>具体的なアプローチ方法</h2><h3 id=パッケージ管理ツールについて>パッケージ管理ツールについて</h3><p>多くの人は <code>use-package</code> や <code>leaf</code> を使っていることでしょう。
<code>use-package</code> の実態はパッケージ管理ツールというよりはmacroです。</p><p><code>use-package</code> 内に適切の設定を記述すると、パッケージを落としパスを通し、関数や変数の設定を記述したりする <code>s式</code> を生成してくれます。
私は <code>use-package</code> には疎いので正確なことは書けませんが、<del>s式</del> の効率がよいかといわれたら最高速をたたき出せるものではありません。</p><p>普通にEmacsの設定をするなら間違いなく使うべきものですが、今回のようなパフォーマンスを求める場合あまりお勧めできるものではありません。</p><h3 id=nativecomp>NativeComp</h3><h4 id=emacsをfull-nativecompでbuildする>EmacsをFull NativeCompでBuildする</h4><p>多くの人はHomebrewのようなパッケージマネージャーで落してBuildしたEmacsを使っていることでしょう。
それだと細かいbuildの設定もできないし、かゆい所に手が届きません。</p><p>まずは <code>git clone</code> をします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ git clone git://git.sv.gnu.org/emacs.git
</span></span><span style=display:flex><span>$ cd emacs
</span></span></code></pre></div><p>次にNativeCompでbuildします。
私は毎日 <code>git pull</code> したうえで次のコマンドを叩いてbuildしています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ./autogen.sh <span style=color:#f92672>&amp;&amp;</span> ./configure --with-native-compilation<span style=color:#f92672>=</span>aot --without-ns --without-x --with-libxml2<span style=color:#f92672>=</span>/usr/bin/xml2-config <span style=color:#f92672>&amp;&amp;</span> make -j8
</span></span><span style=display:flex><span>$ sudo make install
</span></span></code></pre></div><p><code>--with-native-compilation=aot</code> が特に重要です。</p><p><a href=https://blog.tomoya.dev/posts/hello-native-comp-emacs/>ネイティブコンパイルEmacsの登場</a>に書いてありますが、2021年4月ころにNative Compがサポートされました。
<code>foo.el</code> というファイルから <code>foo.eln</code> という拡張子のファイルを生成します。
<code>brew install libgccjit</code> などをしてちゃんと <code>libgccjit</code> をinstallする必要があります。
<a href=https://www.grugrut.net/posts/202104272222/>EmacsのNative Compilationの性能を測定する</a>でも検証されているが、かなりの高速化が期待できます。</p><p><a href=https://github.com/emacs-mirror/emacs/commit/e245c4f226979ccb717cccc8f82b2b0a0f96bdac>Add &ndash;with-native-compilation=aot configuration option</a> で <code>aot</code> を指定してbuildするとEmacsのFull Native Compが実行されるようになりました。
<code>make -j &lt;proc></code> でproc数を多くすると処理が重すぎてPCが固まるので少なめに設定しておく方がよいです。</p><h4 id=nativecompした結果のファイル-eln-が優先的に読み込まれる>NativeCompした結果のファイル（eln）が優先的に読み込まれる</h4><p>Emacs Lispで別のファイルを呼び込む際に <code>(load "/path/to/dir/file")</code> のように書きます。</p><p>実際に、<a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1125-L1639>command-line</a>から <code>init.el</code> や <code>early-init.el</code> を読み込む時にも <code>load</code> は使われています。</p><p><a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1011-L1120>コード(startup&ndash;load-user-init-file)</a>はここです。</p><p><a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/src/lread.c#L1173-L1628>load関数の定義</a> を見てみると、優先的に <code>.eln</code> を読むようになっているようなので早めにNativeCompする必要があります。</p><h4 id=init-dot-elとearly-init-dot-elをbyte-compileする>init.elとearly-init.elをbyte-compileする</h4><p><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/972544d4b66cf5c1a75c>バイトコンパイル - Emacs の起動時間を"&ldquo;詰める&rdquo;"</a>について。</p><p>Byte Compileの<a href=https://ayatakesi.github.io/emacs/24.5/elisp_html/Byte-Compilation.html>ドキュメント</a>には次のような記述があります。</p><blockquote><p>Emacs Lispには、Lispで記述された関数を、より効率的に実行できるバイトコード(byte-code)と呼ばれる特別な表現に翻訳するコンパイラー(compiler)があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義はバイトコードインタープリター(byte-code interpreter)により評価されます。</p></blockquote><p>こんな感じでbyte-compileするとよいです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ emacs -Q --batch -f batch-byte-compile early-init.el
</span></span><span style=display:flex><span>$ emacs -Q --batch -f batch-byte-compile init.el
</span></span></code></pre></div><p>基本的にはnative compが優先的に読まれるので意味がないといわれたらそうなのですが、後述する <code>el-get</code> はbyte-compile時に発行させるので流す必要があります。</p><h4 id=nativecompの設定>NativeCompの設定</h4><p><code>native-comp-speed</code> と <code>native-comp-async-jobs-number</code> を設定するとよいです。</p><p><code>native-comp-speed</code> は最適化オプションで0〜3があります。
<a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/emacs-lisp/comp.el#L46-L58>ソースコード</a>はこちら。
「Warning: with 3, the compiler is free to perform dangerous optimizations.」と書いてありますが、半年以上この設定で問題なく使えているので気にしなくてよいでしょう。</p><p><code>native-comp-async-jobs-number</code> はjob数で大きめに設定するとPCが極端に重くなってしまうので低めに設定しておくことをお勧めします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(with-eval-after-load <span style=color:#e6db74>&#39;comp</span>
</span></span><span style=display:flex><span>  (setq native-comp-async-jobs-number <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>  (setq native-comp-speed <span style=color:#ae81ff>3</span>))
</span></span></code></pre></div><h4 id=init-dot-elとearly-init-dot-elをnativecompする>init.elとearly-init.elをNativeCompする</h4><p><code>native-compile-async</code> でNativeCompileできます。
コンパイル結果の出力は <code>*Async-native-compile-log*</code> bufferです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(native-compile-async <span style=color:#e6db74>&#34;~/.emacs.d/init.el&#34;</span>)
</span></span><span style=display:flex><span>(native-compile-async <span style=color:#e6db74>&#34;~/.emacs.d/early-init.el&#34;</span>)
</span></span></code></pre></div><h3 id=early-init-dot-elについて>early-init.elについて</h3><p><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4#early-init.el>early-init.el - Emacs の起動時間を"&ldquo;詰める&rdquo;"</a>について。</p><p><code>early</code> と書いてあるとおり、初期段階で読み込まれるものです。
「初期段階」で読み込まれるとは具体的に何でしょうか？
<code>early-init.el</code> に書くべき処理とそうでない処理の違いとはなんなのでしょうか？</p><p><a href=https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html>49.4.6 The Early Init File</a>には次のように記述されています。</p><blockquote><p>By contrast, the normal init files are read after the GUI is initialized.</p></blockquote><p>要するに「GUIを初期化するより前に読み込まれる」としか書いてないです。</p><p><code>early-init.el</code> と <code>init.el</code> が読み込まれる間のコードを読むしかないです。</p><p><a href=https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1369-L1479>https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1369-L1479</a></p><p>実行されている主な関数は以下。</p><ul><li>startup&ndash;update-eln-キャッシュ</li><li>package-activate-all</li><li>window-system-initialization</li><li>frame-initialize</li><li>tool-bar-setup</li><li>normal-erase-is-backspace-setup-frame</li><li>tty-register-default-colors</li></ul><p>この辺に関係する設定をすればよいでしょう。</p><p>またC言語側のコードは先に読まれるはずです。
GC関係のコードは<a href=https://github.com/emacs-mirror/emacs/blob/master/src/alloc.c>src/alloc.c</a>に記述されているので、 <code>gc-cons-threshold</code> は <code>early-init.el</code> に書く方がよいです。</p><p>余談ですが、EXWM環境の場合 <code>(setq frame-inhibit-implied-resize t)</code> をするとEXWMがwindow resizeできなくなるので描画がおかしくなるので注意が必要です。</p><h3 id=compile時処理>Compile時処理</h3><h4 id=el-get-bundleをeval-when-compile時に落とす>el-get-bundleをeval-when-compile時に落とす</h4><p>私は <code>el-get</code> ユーザーなので別のpackage managerのことはわかりませんが、package installはbyte-compile時に行っています。
<a href=https://github.com/dimitri/el-get>dimitri/el-get</a>の <code>Installation</code> を参考に設定していきます。</p><p><code>eval-when-compile</code> はbyte-compile時にしか発行せず、生成された <code>elc</code> には処理結果が記述されるというものです。</p><p>私は <code>el-get</code> で380個程度のpackageを落としている関係上、非常に時間がかかるのでshallow cloneするようにしています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(eval-when-compile
</span></span><span style=display:flex><span>  (add-to-list <span style=color:#e6db74>&#39;load-path</span> (locate-user-emacs-file <span style=color:#e6db74>&#34;el-get/el-get&#34;</span>))
</span></span><span style=display:flex><span>  (with-current-buffer
</span></span><span style=display:flex><span>      (url-retrieve-synchronously
</span></span><span style=display:flex><span>       <span style=color:#e6db74>&#34;https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el&#34;</span>)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>goto-char</span> (<span style=color:#a6e22e>point-max</span>))
</span></span><span style=display:flex><span>    (eval-print-last-sexp))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (with-eval-after-load <span style=color:#e6db74>&#39;el-get-git</span>
</span></span><span style=display:flex><span>    (setq el-get-git-shallow-clone <span style=color:#66d9ef>t</span>)))
</span></span></code></pre></div><p>実際にinstallするpackageは次のように記述しています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(eval-when-compile
</span></span><span style=display:flex><span>  (el-get-bundle <span style=color:#e6db74>&#34;yasnippet&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(eval-when-compile
</span></span><span style=display:flex><span>  (el-get-bundle takeokunn/yasnippet-org))
</span></span></code></pre></div><h4 id=環境ごとのif文をmacroで定義する>環境ごとのif文をmacroで定義する</h4><p>私のEmacs環境は3つあります。</p><ul><li>Mac CLI環境</li><li>Mac GUI環境</li><li>Guix exwm環境</li></ul><p>前提にも書いたとおり、今回高速化するにあたって「Mac CLI環境」にフォーカスして話していたが、実際運用している環境は3つあります。
たとえば「Mac環境ではexwm関係のpluginは不要」のような、環境ごとに必要な処理やライブラリが微妙に違うので条件分岐が必要になってきます。</p><p>3環境を分岐できるようなmacroを作成し、byte-compile時に条件分岐しました。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span><span style=color:#75715e>;;; Mac CLI環境</span>
</span></span><span style=display:flex><span>(defmacro when-darwin (<span style=color:#66d9ef>&amp;rest</span> body)
</span></span><span style=display:flex><span>  (when (string= system-type <span style=color:#e6db74>&#34;darwin&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>(progn <span style=color:#f92672>,@</span>body)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;; Mac GUI環境</span>
</span></span><span style=display:flex><span>(defmacro when-darwin-not-window-system (<span style=color:#66d9ef>&amp;rest</span> body)
</span></span><span style=display:flex><span>  (when (and (string= system-type <span style=color:#e6db74>&#34;darwin&#34;</span>)
</span></span><span style=display:flex><span>             <span style=color:#a6e22e>window-system</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>(progn <span style=color:#f92672>,@</span>body)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;; Guix exwm環境</span>
</span></span><span style=display:flex><span>(defmacro when-guix (<span style=color:#66d9ef>&amp;rest</span> body)
</span></span><span style=display:flex><span>  (when (string= system-type <span style=color:#e6db74>&#34;guix&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>(progn <span style=color:#f92672>,@</span>body)))
</span></span></code></pre></div><h3 id=ライブラリ周りの読み込み>ライブラリ周りの読み込み</h3><h4 id=async-loadをする>async loadをする</h4><p><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/c47f8eb7cd547b95ba91>擬似非同期ロードによる"待たされ感"改善 - Emacs の起動時間を"&ldquo;詰める&rdquo;"</a> について。</p><p><code>run-with-timer</code> で起動n秒後にqueue内の処理を順次実行するというアプローチです。</p><p>私はpackageを380個程度入れているので、起動した瞬間に使いたいpackageがなかなかdequeueしてくれないという問題が出てきました。
早く読まれてほしいpackageが以下です。</p><ul><li>dash.elやs.elのようなbasic packages</li><li>amx</li><li>magit</li><li>ddskk</li><li>projectile</li><li>swiper/ivy/counsel</li><li>doom</li></ul><p>普通にEmacsを起動した時最初にたたくコマンドは <code>projectile</code> であることや、 <code>EDITOR=emacs git commit</code> で立ち上がった時さっさと日本語入力できるようにしたいものです。
また、fish shellから <code>M-g</code> でmagitを起動できるようしています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fish data-lang=fish><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>magit</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>set</span> <span style=color:#a6e22e>-l</span> git_root <span style=color:#f92672>(</span><span style=color:#a6e22e>git</span> rev-parse <span style=color:#a6e22e>--show-toplevel</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>emacs</span> <span style=color:#a6e22e>-nw</span> <span style=color:#a6e22e>--eval</span> <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>(progn
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (add-to-list &#39;load-path (locate-user-emacs-file \&#34;el-get/dash\&#34;))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (add-to-list &#39;load-path (locate-user-emacs-file \&#34;el-get/compat\&#34;))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (add-to-list &#39;load-path (locate-user-emacs-file \&#34;el-get/transient/lisp\&#34;))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (add-to-list &#39;load-path (locate-user-emacs-file \&#34;el-get/ghub/lisp\&#34;))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (add-to-list &#39;load-path (locate-user-emacs-file \&#34;el-get/magit-pop\&#34;))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (add-to-list &#39;load-path (locate-user-emacs-file \&#34;el-get/with-editor/lisp\&#34;))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (add-to-list &#39;load-path (locate-user-emacs-file \&#34;el-get/magit/lisp\&#34;))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (require &#39;magit)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  (setq magit-display-buffer-function #&#39;magit-display-buffer-fullframe-status-v1) (magit-status \&#34;</span>$git_root<span style=color:#e6db74>\&#34;))&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fish_user_key_bindings</span>
</span></span><span style=display:flex><span>    bind <span style=color:#ae81ff>\e</span>g magit
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>元記事を参考に優先順位高いqueueを処理する機構も作りました。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(defvar my/delayed-priority-high-configurations <span style=color:#f92672>&#39;</span>())
</span></span><span style=display:flex><span>(defvar my/delayed-priority-high-configuration-timer <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(defvar my/delayed-priority-low-configurations <span style=color:#f92672>&#39;</span>())
</span></span><span style=display:flex><span>(defvar my/delayed-priority-low-configuration-timer <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(add-hook <span style=color:#e6db74>&#39;emacs-startup-hook</span>
</span></span><span style=display:flex><span>          (lambda ()
</span></span><span style=display:flex><span>            (setq my/delayed-priority-high-configuration-timer
</span></span><span style=display:flex><span>                  (run-with-timer
</span></span><span style=display:flex><span>                   <span style=color:#ae81ff>0.1</span> <span style=color:#ae81ff>0.001</span>
</span></span><span style=display:flex><span>                   (lambda ()
</span></span><span style=display:flex><span>                     (if my/delayed-priority-high-configurations
</span></span><span style=display:flex><span>                         (let ((inhibit-message <span style=color:#66d9ef>t</span>))
</span></span><span style=display:flex><span>                           (<span style=color:#a6e22e>eval</span> (pop my/delayed-priority-high-configurations)))
</span></span><span style=display:flex><span>                       (progn
</span></span><span style=display:flex><span>                         (cancel-timer my/delayed-priority-high-configuration-timer))))))
</span></span><span style=display:flex><span>            (setq my/delayed-priority-low-configuration-timer
</span></span><span style=display:flex><span>                  (run-with-timer
</span></span><span style=display:flex><span>                   <span style=color:#ae81ff>0.3</span> <span style=color:#ae81ff>0.001</span>
</span></span><span style=display:flex><span>                   (lambda ()
</span></span><span style=display:flex><span>                     (if my/delayed-priority-low-configurations
</span></span><span style=display:flex><span>                         (let ((inhibit-message <span style=color:#66d9ef>t</span>))
</span></span><span style=display:flex><span>                           (<span style=color:#a6e22e>eval</span> (pop my/delayed-priority-low-configurations)))
</span></span><span style=display:flex><span>                       (progn
</span></span><span style=display:flex><span>                         (cancel-timer my/delayed-priority-low-configuration-timer))))))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(defmacro with-delayed-execution-priority-high (<span style=color:#66d9ef>&amp;rest</span> body)
</span></span><span style=display:flex><span>  (declare (indent <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>(setq my/delayed-priority-high-configurations
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>append</span> my/delayed-priority-high-configurations <span style=color:#e6db74>&#39;,body</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(defmacro with-delayed-execution (<span style=color:#66d9ef>&amp;rest</span> body)
</span></span><span style=display:flex><span>  (declare (indent <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>(setq my/delayed-priority-low-configurations
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>append</span> my/delayed-priority-low-configurations <span style=color:#e6db74>&#39;,body</span>)))
</span></span></code></pre></div><h4 id=autoload-with-eval-after-loadを活用する>autoload/with-eval-after-loadを活用する</h4><p><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/abb04ff2351b3564a1a0>autoload と with-eval-after-load - Emacs の起動時間を"&ldquo;詰める&rdquo;"</a>について。</p><p><code>autoload</code> の挙動は上記の記事に詳細に書かれているので省きます。
ただ、 <code>autoload</code> というのは1つの関数名しか引数に取れないので非常に不便です。
次のような <code>autoload-if-found</code> という関数を作成ました。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(defun autoload-if-found (functions file <span style=color:#66d9ef>&amp;optional</span> docstring interactive type)
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;set autoload iff. FILE has found.&#34;</span>
</span></span><span style=display:flex><span>  (when (locate-library file)
</span></span><span style=display:flex><span>    (dolist (f functions)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>autoload</span> f file docstring interactive type))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>t</span>))
</span></span></code></pre></div><p>使い方はこんな感じです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(autoload-if-found <span style=color:#f92672>&#39;</span>(lsp lsp-deferred) <span style=color:#e6db74>&#34;lsp-mode&#34;</span> <span style=color:#66d9ef>nil</span> <span style=color:#66d9ef>t</span>)
</span></span></code></pre></div><p><code>with-eval-after-load</code> は <code>require</code> が実行されたタイミングで読まれるものです。
<code>autolaod-if-found</code> ですべての処理を遅延している関係で、すべてのpackageに対して丁寧に指定する必要があります。
もし設定をしなければ、未定義変数になって起動時にWarningなりErrorが吐かれてしまいます。</p><p>次の <code>php-mode-</code> の例のように、 <code>with-eval-after-load</code> には3種類の設定をするようにしています。</p><ul><li>hook</li><li>keybind（map）</li><li>custom</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(with-eval-after-load <span style=color:#e6db74>&#39;php-mode</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; hook</span>
</span></span><span style=display:flex><span>  (add-hook <span style=color:#e6db74>&#39;php-mode-hook</span> <span style=color:#a6e22e>#&#39;</span>lsp-deferred)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; keybind</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>define-key</span> php-mode-map (kbd <span style=color:#e6db74>&#34;C-c C--&#34;</span>) <span style=color:#a6e22e>#&#39;</span>php-current-class)
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>define-key</span> php-mode-map (kbd <span style=color:#e6db74>&#34;C-c C-=&#34;</span>) <span style=color:#a6e22e>#&#39;</span>php-current-namespace)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; config</span>
</span></span><span style=display:flex><span>  (setq php-mode-coding-style <span style=color:#e6db74>&#39;psr2</span>))
</span></span></code></pre></div><h3 id=設定>設定</h3><h4 id=magic-file-name-を一時的に無効にする>Magic File Name を一時的に無効にする</h4><p><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4#magic-file-name-%E3%82%92%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AB%E7%84%A1%E5%8A%B9%E3%81%AB%E3%81%99%E3%82%8B>Magic File Name を一時的に無効にする - Emacs の起動時間を"&ldquo;詰める&rdquo;"</a> について。</p><p>FileのI/Oは非常にコストがかかる行為だとあらためて感じました。</p><p>次の記述を書くだけです。
書くだけでかなり改善するのでコスパのよい対応だと感じています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span><span style=color:#75715e>;;; 行頭</span>
</span></span><span style=display:flex><span>(defconst my/saved-file-name-handler-alist file-name-handler-alist)
</span></span><span style=display:flex><span>(setq file-name-handler-alist <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;;; 行末</span>
</span></span><span style=display:flex><span>(setq file-name-handler-alist my/saved-file-name-handler-alist)
</span></span></code></pre></div><h4 id=gcの設定>GCの設定</h4><p><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4#gc-%E3%82%92%E6%B8%9B%E3%82%89%E3%81%99>GC を減らす - Emacs の起動時間を"&ldquo;詰める&rdquo;"</a>について。</p><p>起動時にGCが回ることはっきり言ってコストでしかないです。
起動時に一度もGCを回さない程度の大きさで設定しておくとよいです。</p><p>GCが回ったかどうかは前述の「評価のし方」で <code>profile-report</code> が出力してくれるので、そこで判断できるでしょう。
私は <code>early-init.el</code> に次のように設定しています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(setq gc-cons-threshold (<span style=color:#a6e22e>*</span> <span style=color:#ae81ff>128</span> <span style=color:#ae81ff>1024</span> <span style=color:#ae81ff>1024</span>))
</span></span></code></pre></div><h2 id=その他>その他</h2><h3 id=add-to-listについて>add-to-listについて</h3><p><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/395aeb41a34a616f58bd#%E5%AE%89%E5%85%A8%E3%81%AA%E9%96%A2%E6%95%B0%E3%82%92%E8%AB%A6%E3%82%81%E3%82%8B>安全な関数を諦める - Emacs の起動時間を"&ldquo;詰める&rdquo;"</a> について。</p><p><code>add-to-list</code> を使わずに <code>push</code> を使うほうが重複チェックを行わない関係で速くなるということが書かれています。</p><p><code>add-to-list</code> はプログラミング言語の <code>major-mode</code> や <code>mior-mode</code> で設定する時に使うことが多いです。
私は数十のpackageを入れているのですが、 <code>push</code> に置き換えて事故って動かなくなったことがあります。</p><p>重複チェックをするかどうかで変わる秒数は1msよりも圧倒的に少ないだろうし、安全性を捨てるデメリットと比較してメリットが薄いように感じているので却下しました。</p><p>またasync loadしている関係で言語系の処理は遅延読み込みしているので、起動時には影響が出ないです。</p><h3 id=porテーブル-dumperについて>Porテーブル Dumperについて</h3><p><a href=https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/e27557c39fceefe6c4f6#%E3%83%9D%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB%E3%83%80%E3%83%B3%E3%83%91%E3%83%BC>ポータブルダンパー - Emacs の起動時間を"&ldquo;詰める&rdquo;"</a> について。</p><p>あらかじめpackageを読み込んでおいた状態のmemoryをdumpするしくみ。
今回の遅延評価をするアプローチでは <code>Portable Dumper</code> は活躍できませんでした。</p><p>記述量がほぼない状態のEmacs Lispファイルを用意してmemory dumpして読み込ませてみたところ、180ms程度かかりました。</p><p>そもそもNativeCompしているライブラリはdumpできなかったりといろいろな落とし穴があるらしく、非常に使いにくいものとなっています。
Emacsを自前Buildしたタイミングで生成されるdumpに自分のコードを埋め込むくらいすれば高速になりますが、別途用意をすると非常に遲くなります。</p><h3 id=lsp-modeのperformanceについて>lsp-modeのperformanceについて</h3><p>今回の起動時の高速化には関係ないが、 <code>lsp-mode</code> を高速化するTipsが公式サイトにあります。
私は <code>lsp-mode</code> をヘビーユーズしているので、パフォーマンスが大幅に改善されて生産性が上がりました。</p><p><a href=https://emacs-lsp.github.io/lsp-mode/page/performance/>Performance - lsp-mode</a></p><h3 id=el-getのpackageもnativecompする>el-getのpackageもNativeCompする</h3><p>これも今回の起動時の高速化には関係ないが、el-getで落としてきたpackageも一括でNativeCompする方がよいでしょう。
次のような関数を用意し、あらかじめ実行しておくとよいです。</p><p><code>el-get/**/*.el</code> と <code>elpa/**/*.el</code> のすべてのファイルを再帰的にNativeCompするため時間がかかります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-emacs-lisp data-lang=emacs-lisp><span style=display:flex><span>(defun my/native-comp-packages ()
</span></span><span style=display:flex><span>  (interactive)
</span></span><span style=display:flex><span>  (native-compile-async <span style=color:#e6db74>&#34;~/.emacs.d/init.el&#34;</span>)
</span></span><span style=display:flex><span>  (native-compile-async <span style=color:#e6db74>&#34;~/.emacs.d/early-init.el&#34;</span>)
</span></span><span style=display:flex><span>  (native-compile-async <span style=color:#e6db74>&#34;~/.emacs.d/el-get&#34;</span> <span style=color:#e6db74>&#39;recursively</span>)
</span></span><span style=display:flex><span>  (native-compile-async <span style=color:#e6db74>&#34;~/.emacs.d/elpa&#34;</span> <span style=color:#e6db74>&#39;recursively</span>))
</span></span></code></pre></div><h2 id=終わりに>終わりに</h2><p>2022年はEmacsとひたすら向きあった1年でした。
今後10〜15年耐えられる設定とはなんなのかを考えた結果の1つに「起動時間の高速化」というのがありました。
ゼロから設定を見直し、より高速かつメンテナンス性の高い記述方法はなんなのか、 <code>emacs.d</code> はどうあるべきか、より善く生きていくためにはどうすればよいのかを考えつくしました。</p><p>Emacs起動時間を高速化するにあたって、Emacs本体のソースコードを読む機会が増えて多くの知識を得ることができました。
ぜひ皆さんも自分の設定をあらためて見直すきっかけにしていただけると幸いです。</p><p>いつもTwitterで疑問に答えてくれるEmacs Hackerの皆さんのおかげでこの記事を書くことができました。
今後ともよろしくお願いします。</p></div></article></main></div><footer class=footer role=contentinfo><div class=footer_social-icons><a href=https://zenn.dev/takeokunn target=_blank rel="noopener noreferrer me" title=Zenn aria-label="Visit Zenn profile"><svg viewBox="0 0 88 88" aria-hidden="true" focusable="false"><path d="M2.22 83.478h17.632c1.296.0 2.16-.576 2.952-1.584L67.906 17.092c.576-.864.288-1.728-.576-1.728H51.946c-1.008.0-1.656.432-2.304 1.296L3.948 81.606c-.648.936-.288 1.872.864 1.872H2.22z" fill="currentColor"/><path d="M54.106 83.478h15.336c1.152.0 1.656-.36 1.656-1.224.0-.36-.144-.792-.432-1.296l-18-28.208c-.504-.792-1.296-.792-1.944.0L42.73 65.998c-.432.72-.36 1.512.144 2.304l8.928 14.112c.504.72 1.152 1.064 2.304 1.064z" fill="currentColor"/></svg>
</a><a href=https://x.com/takeokunn/ target=_blank rel="noopener noreferrer me" title=Twitter aria-label="Visit Twitter profile"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</a><a href=https://github.com/takeokunn target=_blank rel="noopener noreferrer me" title=GitHub aria-label="Visit GitHub profile"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://keyoxide.org/0B10DAA7BA0236D7382287660F79C0AB03FD7A1C target=_blank rel="noopener noreferrer me" title=Keyoxide aria-label="Visit Keyoxide profile"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5.0 11-7.778 7.778 5.5 5.5.0 017.777-7.777zm0 0L15.5 7.5m0 0 3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>
</a><a href=/index.xml target=_blank rel="noopener noreferrer" title=RSS aria-label="Subscribe via RSS"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div><small class=footer_copyright><span aria-label=Copyright>© 2026 takeokunn</span>
<span class=footer_divider aria-hidden=true>•</span>
<span>Powered by <a href=https://github.com/takeokunn/hugo-take-theme target=_blank rel=noopener aria-label="Hugo Take Theme on GitHub">hugo-take-theme</a></span></small></footer></body></html>