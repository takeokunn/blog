{
  "id": "1409951D-E05B-4DEB-9388-1B6A2185A29B",
  "title": "TwitterUIDの挙動とJavaScriptのBigIntについて",
  "raw": ":PROPERTIES:\n:ID:       1409951D-E05B-4DEB-9388-1B6A2185A29B\n:mtime:    20231217120026\n:ctime:    20221215031447\n:END:\n#+TITLE: TwitterUIDの挙動とJavaScriptのBigIntについて\n#+AUTHOR: takeokunn\n#+DESCRIPTION: TwitterUIDの挙動とJavaScriptのBigIntについて\n#+DATE: 2020-10-28T09:00:00+09:00\n#+HUGO_BASE_DIR: ../../\n#+HUGO_SECTION: posts/permanent\n#+HUGO_CATEGORIES: permanent\n#+HUGO_TAGS: javascript twitter\n#+HUGO_DRAFT: false\n#+STARTUP: fold\n\nTwitterのUIDについて調べてたら、自分の浮動小数点の挙動についての理解度が低かったので調べたことについてまとめておく。\n\n--------------\n\nことの発端は、spreadsheet上の人力で管理されているTwitterのユーザー情報をデータベースに入れる作業をしていた時だった。\n\n以前同じような作業をしたとき結構漏れがあったので、Twitter UIDの妥当性やscreen nameが本当に存在するかどうかを確認する必要があった。\n\n[[https://idtwi.com/][TwitterのIDチェッカー]]などのWebサイトを利用してもよかったが、100件を超える量のデータを手動で確認取るのは面倒だったため、次のような検証scriptを雑に書いた。\n\n#+begin_src shell\n  #!/bin/bash\n  while read row; do\n      TWITTER_ID=`echo ${row} | cut -d , -f 1`\n      TWITTER_UID=`echo ${row} | cut -d , -f 2`\n      TWITTER_REQUEST_UID=`curl -X GET -H \"Authorization: Bearer <TWITTER_TOKEN>\" -s \"https://api.twitter.com/1.1/users/show.json?screen_name=${TWITTER_ID}\" | jq \".id\"`\n      if [ ${TWITTER_REQUEST_UID} -ne ${TWITTER_UID} ]; then\n          echo \"${TWITTER_ID}: ${TWITTER_UID} → ${TWITTER_REQUEST_UID}\"\n      fi\n  done < ~/Desktop/twitter.csv\n#+end_src\n\nそうしたら半分くらいのTwitter UIDがずれてしまった。明らかにおかしいと思ったので、きちんと調査することにした。\n\n--------------\n\nTwitter Developer Documentに ~Twitter IDs~ という記事がある。\n\n[[https://developer.twitter.com/en/docs/twitter-ids]]\n\n次のようなことが書かれていた。\n\n- ユーザーの増加によりTwitterのUIDは64bit\n- unsignedでuniqueな値として管理されている\n- JavaScriptの整数のサイズは53bitに制限されている\n- api responseでは整数(~id~)と文字列(~id_str~)の両方を返すような実装になっている\n\nここから分かるのは、自分は↑のshell scriptで ~id~ を見ていたから正しい値をとれていなかった、~id_str~ を使うべきだったことが分かる。\n\nたしかに、次のように =toString()= をしたらずれることについて確認がとれたがどうしてだろうか。\nまた、今回はbash scriptを書いたのにJavaScriptと同じ挙動をするのはどうしてなのか調べる必要がある。\n\n\n#+begin_src shell\n  ~ ｡+ﾟ(∩´﹏'∩)ﾟ+｡ < node\n  Welcome to Node.js v15.0.1.\n  Type \".help\" for more information.\n  > (10765432100123456789).toString()\n  '10765432100123458000'\n#+end_src\n\n--------------\n\nJavaScriptの数値については [[https://qiita.com/uhyo/items/f9abb94bcc0374d7ed23][JavaScriptの数値型完全理解]]が一番良くまとまっていた。\n\nこれによると、JavaScriptの数値型はすべて ~IEEE 754~ 倍精度の浮動小数点（double型）で表現されている。たしかに、[[https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number][MDNのNumberの記事]]にも同じような記述がある。\n\ndouble型で安全に表現できる最大値は ~Number.MAX_SAFE_INTEGER~ で取ることができ、 ~Number.isSafeInteger()~ などでもチェックできる。\n\n#+begin_src shell\n  > Number.isSafeInteger(10765432100123456789)\n  false\n  > Number.MAX_SAFE_INTEGER\n  9007199254740991\n#+end_src\n\nJavaScriptには ~bigint~ も用意されている。\n\nMDNには次のように書かれているので日常使いするのは辞めておくべきだろう。\n\n#+begin_quote\nNumber と BigInt との間の型変換は精度が落ちる可能性があるため、 BigInt\nは値が論理的に253以上になる場合にのみ使用し、この2つの型の間で型変換を行わないこと推奨します。\n\n#+end_quote\n\n[[https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/BigInt]]\n\nさきほどの巨大な値でも正確に出力できる。\n\n#+begin_src shell\n  > (10765432100123456789n).toString()\n  '10765432100123456789'\n#+end_src\n\n[[https://caniuse.com/bigint][caniuse]]を見ているとほとんどのブラウザがBigIntに対応されているので問題なく使えるみたいだ。\n\n--------------\n\n浮動小数点にの挙動についてもう少し見てみる。\n\nググったらいっぱい出てくるので計算方法は割愛するが、[[https://www.cc.kyoto-su.ac.jp/~yamada/programming/float.html][浮動小数点数型と誤差]]に分かり易くまとまっている。\n\n#+begin_example\ndouble の表す値　＝　(-1)^符号部 × 2^(指数部-1023) × 1.仮数部\n#+end_example\n\n#+caption:\n[[https://www.cc.kyoto-su.ac.jp/~yamada/programming/double.png]]\n\n- 符号は、0なら正、1なら負\n- 指数部は、「2^指数」の指数の部分に1023を引いたものが11bit符号なしの整数の形で格納されている\n- 仮数部は、実際の仮数部の先頭の「1」を取り除いた残りが格納されている\n\nという風に格納される。\n\n仮数部が52bitだが、double型の精度が53bitなのは =1.仮数部= の =1=\n部分もカウントされるからみたいだ。\n\n[[https://news.mynavi.jp/article/architecture-93/][ヒドン(Hidden)ビットで精度を1ビットを稼ぐ]]がおもしろかった。\n\n今回の問題はJavaScriptというよりは浮動小数点の問題なのでbashでも同じ。\n\n-------\n\n昔CSの授業で習った気もするけどすっかり忘れていたので今一度勉強できてよかった。\n",
  "backlinks": []
}