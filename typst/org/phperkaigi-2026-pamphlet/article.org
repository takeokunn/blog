:PROPERTIES:
:ID:       795ABE1A-4CCA-66E4-C9AB-37D82893C7D3
:END:
#+TITLE: パッケージマネージャNixで実現する宣言的でクリーンなPHP開発環境の構築
#+AUTHOR: takeokunn
#+STARTUP: fold
#+BEGIN_EXPORT typst
#set text(lang: "ja", font: "HackGen", size: 8pt)

#set page(
  width: 210mm,
  height: 297mm,
  margin: 20mm,
  columns: 2
)
#set columns(gutter: 12pt)

#import "@preview/codly:1.2.0": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()
#codly(languages: codly-languages)

// コードブロックのフォントサイズを小さくしてカラムに収める
#show raw: set text(size: 6pt)

// タイトルを全幅で表示
#place(
  top + center,
  float: true,
  scope: "parent",
  clearance: 1em,
)[
  #set text(size: 18pt)
  パッケージマネージャNixで実現する \
  宣言的でクリーンなPHP開発環境の構築

  #set text(size: 12pt)
  たけてぃ \@takeokunn
]
#+END_EXPORT
* はじめに

PHP開発者にとって環境構築は永遠の課題です。
PHP 8.3や8.0といったバージョンの違い、拡張モジュールの違いなど、複数プロジェクトを並行開発する際に環境の混在は避けられません。
本業とOSS・副業プロジェクトの環境が混在し、マシン買い替え時の環境再構築に苦労した経験は誰しもあるのではないでしょうか。

環境構築で遭遇する典型的な問題を挙げてみます。

- =pecl install redis= が謎のコンパイルエラーで失敗する
- Intel MacからApple Silicon Macへの移行でHomebrewのパスが変わり環境が壊れる
- =brew upgrade= したら依存していたPHPバージョンが消えてプロジェクトが動かなくなる
- 新メンバーのオンボーディングで「READMEの手順通りにやったのに動かない」と言われる
- 半年ぶりに触るプロジェクトの環境構築手順を思い出せない

これらの問題の多くは、環境構築が「手順の実行」に依存していることに起因します。
手順書は陳腐化し、環境は人によって微妙に異なり、再現性が担保されません。

本記事ではそんな環境構築の課題を解決する選択肢として、パッケージマネージャNixとdevenvを使った宣言的なPHP開発環境の構築について紹介します。

* Nixについて
** 概要

Nix[fn:1]は2003年にEelco Dolstra氏によって開発された純粋関数型パッケージマネージャです。
従来のパッケージマネージャと異なり、パッケージを副作用なく管理できることが特徴です。

Nixの最大の特徴は「宣言的管理」です。
「あるべき状態」を設定ファイルに記述し、Nixがその状態を実現します。
これにより、設定ファイル自体が環境のドキュメントとなり、半年後の自分でも同じ環境を再現できます。

Nixはパッケージマネージャとしてだけでなく、NixOS（Linuxディストリビューション）やnix-darwin（macOS設定管理）の基盤技術でもあります。
本記事ではパッケージマネージャとしてのNixに焦点を当てます。

[fn:1] Nix, https://nixos.org/

** nixpkgsとバイナリキャッシュ

nixpkgs[fn:2]はNixの公式パッケージリポジトリで、10万以上のパッケージが含まれています。
GitHubで最もアクティブなリポジトリの一つで、PHPも複数バージョン（8.0〜8.4）が利用可能です。

#+begin_src bash
  # nixpkgsで利用可能なPHPバージョンを確認
  $ nix search nixpkgs php
  # php82, php83, php84 などが表示される
#+end_src

Nixはデフォルトでcache.nixos.orgからビルド済みバイナリをダウンロードします。
ソースからビルドする必要がないため、 =brew install= と同等の速度でパッケージをインストールできます。

#+begin_src bash
  # バイナリキャッシュから取得（数秒〜数十秒）
  $ nix run nixpkgs#php

  # キャッシュがない場合はソースビルド（数分〜数十分）
  # → 通常のパッケージはほぼキャッシュが存在
#+end_src

[fn:2] nixpkgs, https://github.com/NixOS/nixpkgs

** Nixの仕組み
*** Nixストアによるパッケージ分離

従来のパッケージマネージャでは =/usr/local/bin/php= のような共有パスを使うため、PHP 8.3と8.1を同時にインストールすると衝突が発生します。

Nixはすべてのパッケージを =/nix/store= という専用ディレクトリに、ハッシュ値を含むパスで保存します。

#+begin_src bash
/nix/store/abc123...-php-8.3.0/bin/php
/nix/store/def456...-php-8.1.27/bin/php
/nix/store/ghi789...-composer-2.7.1/bin/composer
#+end_src

このハッシュ値はソースコード、ビルド手順、依存関係から計算されます。
同じ入力からは必ず同じハッシュが生成されるため、ビルドの再現性が保証されます。

*** 再現性の保証

Nixのビルドはサンドボックス環境で実行され、ネットワークアクセスや環境変数が遮断されます。
これにより「自分のマシンでは動くのに」という問題を大幅に減らせます。

#+begin_src bash
# 同じflake.lockを使えば、誰がいつどこでビルドしても同じ結果
$ nix build .#myapp  # → /nix/store/xyz789...-myapp

# 1年後に別のマシンで実行しても同じハッシュ
#+end_src

PHPの =composer.lock= が依存ライブラリを固定するように、Nixは実行環境全体（PHP本体、拡張モジュール、システムライブラリ）を固定します。

*** シンボリックリンクによる環境切り替え

=/nix/store= 内の各パッケージは「プロファイル」というシンボリックリンクの集合を通じて使います。
Nixは必要なパッケージだけを参照するプロファイルを作成します。

#+begin_src bash
~/.nix-profile/bin/php -> /nix/store/abc123...-php-8.3.0/bin/php
~/.nix-profile/bin/composer -> /nix/store/ghi789...-composer-2.7.1/bin/composer
#+end_src

プロジェクトごとに異なるプロファイルを持てるため、Aプロジェクトでは PHP 8.3、BプロジェクトではPHP 8.1 といった使い分けが可能です。
実体は =/nix/store= に共存しており、シンボリックリンクの切り替えだけで環境が変わります。

*** ガベージコレクションとロールバック

=/nix/store= には使用中・未使用のパッケージが蓄積されていきます。
不要なパッケージは =nix-collect-garbage= で削除できます。

#+begin_src bash
  # 未使用パッケージの削除
  $ nix-collect-garbage

  # 古い世代も含めて削除（より多くの容量を解放）
  $ nix-collect-garbage -d

  # ストアの容量確認
  $ du -sh /nix/store
#+end_src

Nixは環境の「世代」を保持しているため、問題が発生した場合は以前の状態にロールバックできます。
PHPのバージョンアップで不具合が出ても、すぐに元の環境に戻せる安心感があります。

*** Flakesによる厳密なバージョン管理

=flake.lock= はnixpkgsのリビジョン（コミットハッシュ）を記録します。
nixpkgsには10万以上のパッケージが含まれており、リビジョンを固定することで、PHP、MySQL、Node.jsなどすべてのパッケージのバージョンが一意に決まります。

#+begin_src json
// flake.lock（一部抜粋）
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "rev": "abc123...",
        "type": "github"
      }
    }
  }
}
#+end_src

=flake.lock= をGit管理すれば、チーム全員が同じバージョンのパッケージを使えます。
=composer.lock= がPHPライブラリを固定するように、 =flake.lock= は実行環境全体を固定します。

** Homebrewとの共存

「すでにHomebrewを使っているけど、Nixに完全移行しないといけない？」という疑問があるかもしれません。
答えはNoです。NixとHomebrewは問題なく共存できます。

Nixは =/nix/store= という独立したディレクトリにパッケージを配置し、Homebrewの =/opt/homebrew= （Apple Silicon）や =/usr/local= （Intel）とは完全に分離されています。
PATHの優先順位を調整すれば、プロジェクトではNix、それ以外ではHomebrewという使い分けも可能です。

devenvとdirenvを組み合わせれば、プロジェクトディレクトリに入ったときだけNixの環境が有効になり、ディレクトリを出ればHomebrewの環境に戻ります。
既存の環境を壊すことなく、段階的にNixを導入できるのは大きなメリットです。

** 既存ツールの課題

PHP開発環境の構築には様々なツールが存在しますが、それぞれに課題があります。

*Homebrew* はグローバル環境を汚染し、 =brew unlink= / =brew link= によるバージョン切り替えは煩雑です。
=php@8.1= と =php@8.3= を同時にアクティブにできず、プロジェクト間の切り替えが手動になります。

*Docker* はオーバーヘッド（起動時間、メモリ消費）が大きく、macOSではファイル同期の遅延が開発体験を損ないます。
企業規模によってはDocker Desktopのライセンス費用も考慮が必要です。

*phpenv/asdf/mise* は古いPHPバージョンのビルド失敗が頻発します。
macOSのシステムライブラリ変更（特にOpenSSL、libxml2）の影響を受けやすく、 =brew install openssl= してからパスを通すなどの作業が必要になることがあります。

NixとDockerの使い分けについても触れておきます。
*ローカル開発* ではNix/devenvが適しています。起動が一瞬で、ファイルI/Oもネイティブ速度です。
*本番環境・CI/CD* ではDockerが依然として有力です。コンテナイメージによるデプロイの一貫性、Kubernetesとの親和性は大きなメリットです。
両者は排他的ではなく、「ローカルはNix、デプロイはDocker」という組み合わせも現実的な選択肢です。

** 宣言的管理の特徴

NixはIaC（Infrastructure as Code）の考え方を開発環境に適用したものです。
TerraformがAWSリソースを =.tf= ファイルで定義するように、Nixは開発環境を設定ファイルで定義します。

#+begin_src bash
  # 命令的（Homebrew）- 手順を実行
  $ brew install php@8.3 && pecl install redis xdebug
  # → 手順書が必要、環境差異が発生しやすい
#+end_src

#+begin_src nix
  # 宣言的（Nix）- あるべき状態を記述
  { pkgs, ... }: {
    languages.php = {
      enable = true;
      package = pkgs.php83.buildEnv {
        extensions = { all, enabled }: with all; enabled ++ [ redis xdebug ];
        extraConfig = "memory_limit = 256M";
      };
    };
  }
  # → 設定ファイル自体がドキュメント
#+end_src

命令的アプローチは「どうやって構築するか」を記述し、宣言的アプローチは「どうあるべきか」を記述します。
Nixが差分を検出し、あるべき状態に収束させます。

** 言語仕様

Nix言語は純粋関数型言語で、パッケージのビルド定義に特化しています。
構文はJSONを拡張したような形式で、関数や変数束縛が追加されています。

#+begin_src nix
  # 基本的な値
  "hello"              # 文字列
  42                   # 数値
  true                 # 真偽値
  [ 1 2 3 ]            # リスト
  { name = "php"; }    # アトリビュートセット
#+end_src

関数は =引数: 本体= の形式で定義します。

#+begin_src nix
  # 関数定義
  add = x: y: x + y;   # add(1)(2) => 3

  # パターンマッチ引数（devenv.nixでよく見る形）
  { pkgs, ... }: { languages.php.enable = true; }
#+end_src

=let ... in= で変数を束縛し、 =with= でスコープを簡略化できます。

#+begin_src nix
  let
    phpVersion = "8.3";
  in {
    packages = with pkgs; [ php composer nodejs ];
    # pkgs.php, pkgs.composer... と書く代わりに短縮
  }
#+end_src

詳細は公式マニュアル[fn:3]を参照してください。

[fn:3] Nix Language, https://nix.dev/manual/nix/latest/language/

* PHPを取り巻くNix環境

NixでPHP開発環境を構築する方法は主に3つあります。

従来の *nix-shell* は =shell.nix= を記述して環境に入る方法ですが、依存関係のバージョン固定が弱く再現性に課題があります。
*Nix Flakes* は =flake.nix= と =flake.lock= で厳密なバージョン管理を実現しますが、Nix言語の知識が必要でPHP向けの設定は冗長になりがちです。

Nixを簡単に使うためのラッパーツールとして *devbox*[fn:4] と *devenv*[fn:5] があります。

*devbox* はJetpack社が開発するツールで、JSONベースの設定ファイルを使用します。
Nix言語を一切書かずに環境構築できるため、導入障壁が最も低いのが特徴です。

#+begin_src json
// devbox.json
{
  "packages": ["php83", "php83Extensions.redis", "nodejs_20"]
}
#+end_src

一方、 *devenv* はCachix社が開発するFlakesベースのツールです。
Nix言語で記述しますが、言語ごとに最適化されたオプションを提供します。

#+begin_src nix
# devenv.nix
{ pkgs, ... }: {
  languages.php.enable = true;
  languages.php.package = pkgs.php83.buildEnv {
    extensions = { all, enabled }: with all; enabled ++ [ redis ];
  };
}
#+end_src

devboxは手軽さが魅力ですが、devenvはサービス統合（MySQL、Redis等）、pre-commitフック、カスタムスクリプトなど、より高度な機能を備えています。
PHP開発では拡張モジュールの細かな設定やphp.iniのカスタマイズが必要になることが多いため、本記事ではより自由度の高いdevenvを使った環境構築を紹介します。

[fn:4] devbox, https://www.jetify.com/devbox
[fn:5] devenv, https://devenv.sh/

* devenvについて
** 概要

devenvを使えば、学習コストを最小限に抑えてすぐにNixを使い始められます。

devenvは =devenv.nix= と =devenv.lock= の2つのファイルでプロジェクトの開発環境を定義します。
=devenv.nix= には言語、パッケージ、サービス、スクリプトなどを記述し、 =devenv.lock= で依存関係のバージョンを固定します。
=devenv shell= コマンドで定義した環境に入り、 =devenv up= でMySQLやRedisなどのサービスを起動できます。

セットアップは以下の手順で完了します。

#+begin_src bash
  # Nixのインストール(例)
  $ curl -L https://nixos.org/nix/install | sh

  # Flakesの有効化（~/.config/nix/nix.conf）
  # experimental-features = nix-command flakes

  # devenvのインストール
  $ nix-shell -p devenv

  # プロジェクトの初期化
  $ cd myproject
  $ devenv init
#+end_src
** PHP環境の設定

devenv.nixファイルにPHP環境を記述します。
PHPのバージョン、拡張モジュール、php.iniの設定、追加パッケージなどを一箇所で管理できます。

#+begin_src nix
  # devenv.nix
  { pkgs, ... }:
  {
    languages.php = {
      enable = true;
      package = pkgs.php83.buildEnv {
        extensions = { all, enabled }:
          with all; enabled ++ [ redis xdebug pdo_mysql mbstring gd ];
        extraConfig = ''
          memory_limit = 256M
          display_errors = On
          xdebug.mode = debug
        '';
      };
    };

    packages = with pkgs; [ nodejs_20 yarn ];

    enterShell = ''
      echo "PHP $(php -v | head -n1)"
    '';
  }
#+end_src

各ディレクトリにdevenv.nixを配置するだけで、本業プロジェクト（PHP 8.3）、副業案件（PHP 8.1）、個人OSS（PHP 8.4）といった複数環境を完全分離できます。

** スクリプトとフック

devenvでは =scripts= でカスタムコマンドを、 =git-hooks.hooks= でGitフックを定義できます。

#+begin_src nix
  { pkgs, ... }:
  {
    languages.php.enable = true;

    # カスタムスクリプト
    scripts = {
      lint.exec = ''
        ./vendor/bin/phpcs --standard=PSR12 src/
      '';
      format.exec = ''
        ./vendor/bin/php-cs-fixer fix
      '';
      analyze.exec = ''
        ./vendor/bin/phpstan analyse src/ --level=max
      '';
      ci.exec = ''
        lint && analyze && test
      '';
      test.exec = ''
        ./vendor/bin/phpunit
      '';
    };

    # Git pre-commitフック
    git-hooks.hooks = {
      check-php-cs-fixer = {
        enable = true;
        name = "PHP CS Fixer";
        entry = "./vendor/bin/php-cs-fixer fix --dry-run --diff";
        files = "\\.php$";
      };
      check-phpstan = {
        enable = true;
        name = "PHPStan";
        entry = "./vendor/bin/phpstan analyse --no-progress";
        files = "\\.php$";
        pass_filenames = false;
      };
    };
  }
#+end_src

=lint= という名前で定義したスクリプトは =lint= コマンドとしてシェル内で直接実行できます。
pre-commitフックは =devenv shell= に入ると自動的にセットアップされ、コミット時に実行されます。

** 環境変数とシークレット管理

開発用の環境変数は =env= で直接定義するか、 =dotenv= で =.env= ファイルから読み込めます。

#+begin_src nix
  { pkgs, ... }:
  {
    # 環境変数の直接定義
    env = {
      APP_ENV = "development";
      APP_DEBUG = "true";
      LOG_LEVEL = "debug";
    };

    # .envファイルから読み込み
    dotenv.enable = true;

    # シェル起動時に動的に設定
    enterShell = ''
      export APP_KEY=$(cat .app-key 2>/dev/null || echo "base64:dummy")
      export PATH="$PWD/vendor/bin:$PATH"
    '';
  }
#+end_src

本番用シークレットは =.env= をgitignoreに追加し、 =.env.example= をリポジトリに含める従来のパターンがそのまま使えます。

** サービス統合

devenvはDockerなしでデータベースやキャッシュサーバを起動できます。[fn:6]
=devenv up= でサービスを起動し、データは =.devenv/= に保存されます。

#+begin_src nix
  { pkgs, ... }:
  {
    services.mysql = {
      enable = true;
      initialDatabases = [{ name = "myapp"; }];
    };

    services.redis.enable = true;
    services.mailhog.enable = true;
  }
#+end_src

[fn:6] Supported Services - devenv, https://devenv.sh/services/

** direnvとの連携

direnv[fn:7]と連携することで、ディレクトリ移動だけで環境が自動的に切り替わります。
プロジェクトルートに =.envrc= ファイルを作成し、以下を記述します。

#+begin_src bash
  # direnvのセットアップ
  eval "$(devenv direnvrc)"
  use devenv
#+end_src

=direnv allow= で許可すると、以降は =cd= するだけで環境が切り替わります。

#+begin_src bash
  $ cd ~/projects/legacy-app    # PHP 8.1環境に自動切り替え
  direnv: loading .envrc
  PHP 8.1.x

  $ cd ~/projects/new-app       # PHP 8.3環境に自動切り替え
  direnv: loading .envrc
  PHP 8.3.x
#+end_src

「このプロジェクトはPHP何だっけ？」と悩む必要がなくなります。

[fn:7] direnv, https://direnv.net/

* 終わりに

筆者は本業・副業・OSSの全プロジェクトでdevenvを使っており、環境構築で悩む時間が大幅に減りました。
devenvは非常に便利なツールです。

Nixには学習コストがありますが、devenvを使えばその壁を大幅に下げられます。
興味のある方はぜひNix公式サイト[fn:1]やdevenv公式ドキュメント[fn:5]を参照してみてください。

Nixの適用範囲は開発環境だけではありません。
home-manager[fn:8]を使えばgit、vim、zshなどの開発ツールや、シェルの設定ファイル（dotfiles）も宣言的に管理できます。
さらにnix-darwin（macOS）やNixOS（Linux）を使えば、OS全体の設定をNixで管理することも可能です。
「開発環境のIaC」から始めて、徐々に管理範囲を広げていくのも良いでしょう。

また、Software Design 2025年9月号〜2026年1月号にてNixの連載記事を執筆しました。
本記事で興味を持たれた方は、ぜひそちらもご覧ください。

[fn:8] home-manager, https://nix-community.github.io/home-manager/
