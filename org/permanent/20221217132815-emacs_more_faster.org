:PROPERTIES:
:ID:       3FBA1A73-2AE5-4305-BA25-61E67DB91028
:mtime:    20221217142901 20221217132858
:ctime:    20221217132815
:END:

#+TITLE: Emacsを世界最速級で起動する方法
#+DESCRIPTION: description
#+DATE: 2022-12-17
#+HUGO_BASE_DIR: ../../
#+HUGO_SECTION: posts/permanent
#+HUGO_TAGS: permanent emacs
#+HUGO_DRAFT: true
#+STARTUP: content
#+STARTUP: nohideblocks

[[https://qiita.com/advent-calendar/2022/emacs][Emacs Advent Calendar 2022]] 19日目です。

[[https://qiita.com/advent-calendar/2022/vim][Vim Advent Calendar 2022]] 3日目の [[https://qiita.com/delphinus/items/fb905e452b2de72f1a0f][爆速で起動する Neovim を作る]] に触発されて、「自分もEmacs版を書くぞ!」ということで書いていきます。

なお、VimとEmacsの比較をし易くするためになるべく文章の構成を寄せて書くことをご了承ください。

* はじめに

「Emacsを高速に起動する」ということに対して、多くのEmacsユーザは興味がありません。
本来Emacsというのは常に起動し続けるものであり、必要に応じてEmacs Lispを適用し、テキストエディタをカスタマイズしていくものです。
現に「Emacs, 起動, 高速化」と検索すると、「4000msを1000msにした」のような秒単位での高速化の記事ばかりみつかります。

もし貴方が設定を変えずに手軽に高速に起動したい場合は ~emacs --daemon~ でdaemonを立ち上げ、 ~emacsclient~ で繋ぐようにすれば良いでしょう。
私は他人のdotfilesを読むのが趣味なのですが、多くのEmacsユーザは ~EDITOR=emacsclient~ と設定しています。

また、起動時間のみを考慮するなら =~/.emacs.d/init.el= を削除して素で起動すれば良いでしょう。
そうなると純粋にマシンスペックの勝負になります。
Emacsは素の状態でも十分魅力的な機能を多数盛り込まれているが、カスタマイズしてこそ真価を発揮するエディタなのでアプローチとしてはイマイチでしょう。

この記事を読む前に [[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4][Emacs の起動時間を""詰める""]] を熟読することを推奨しています。
特に以下のChapterは非常に有益なテクニックが詰め込まれており、大幅な速度改善を見込めます。

- [[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/abb04ff2351b3564a1a0][autoload と with-eval-after-load]]
- [[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/c47f8eb7cd547b95ba91][擬似非同期ロードによる"待たされ感"改善]]
- [[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/dcebc13578d42055f8a4][その他のテクニック：不要な処理を省くハックたち]]

本のあらすじにも書いてある通り、Emacs自体に既に大量のファイルがある状態で高速に起動する時点で自分の設定を見直さなければならないことは明白でしょう。

#+begin_quote
しかし、考えてみれば Emacs には 1000 以上の Emacs Lisp ファイルが初めから同梱されているわけで、そこに数十のプラグインを足しただけで爆裂に遅くなるのは、なにか設定にも問題がある気がします。
#+end_quote

詳細は後述しますが、現在の私のEmacsは15〜25ms程度で起動をします。
一切設定を読まずに素で起動するコマンド ~emacs -Q~ で起動させると2ms程度です。
まだまだ高速に起動させる余地はありますが、「高速に起動させることができている」と自負しても問題ないでしょう。

#+begin_example
  Emacs booting time: 20 [msec] = ‘emacs-init-time’.
  Loading init files: 10 [msec], of which 1 [msec] for ‘after-init-hook’.
#+end_example

* 前提
** 環境

2022年12月現在、 ~Macbook Pro 16-inch, 2019~ の標準モデルを使っています。

#+begin_src shell
  $ neofetch
                      'c.          take@obaranoMacBook-Pro.local
                   ,xNMM.          -----------------------------
                 .OMMMMo           OS: macOS 13.1 22C65 x86_64
                 OMMM0,            Host: MacBookPro16,1
       .;loddo:' loolloddol;.      Kernel: 22.2.0
     cKMMMMMMMMMMNWMMMMMMMMMM0:    Uptime: 1 day, 18 hours, 29 mins
   .KMMMMMMMMMMMMMMMMMMMMMMMWd.    Packages: 347 (brew)
   XMMMMMMMMMMMMMMMMMMMMMMMX.      Shell: fish 3.5.1
  ;MMMMMMMMMMMMMMMMMMMMMMMM:       Resolution: 1792x1120@2x
  :MMMMMMMMMMMMMMMMMMMMMMMM:       DE: Aqua
  .MMMMMMMMMMMMMMMMMMMMMMMMX.      WM: Quartz Compositor
   kMMMMMMMMMMMMMMMMMMMMMMMMWd.    WM Theme: Blue (Dark)
   .XMMMMMMMMMMMMMMMMMMMMMMMMMMk   Terminal: tmux
    .XMMMMMMMMMMMMMMMMMMMMMMMMK.   CPU: Intel i7-9750H (12) @ 2.60GHz
      kMMMMMMMMMMMMMMMMMMMMMMd     GPU: Intel UHD Graphics 630, AMD Radeon Pro 5300M
       ;KMMMMMMMWXXWMMMMMMMk.      Memory: 9716MiB / 16384MiB
         .cooc,.    .,coo:.
#+end_src

Emacsのversionは ~30.0.50~ です。
日々HEAD buildをしているのでstableのversionとは微妙に差異がありますがそこまで大きな差がでないでしょう。

#+begin_src shell
  $ emacs -version
  GNU Emacs 30.0.50
  Development version 6a390fd42ec4 on master branch; build date 2022-12-17.
  Copyright (C) 2022 Free Software Foundation, Inc.
  GNU Emacs comes with ABSOLUTELY NO WARRANTY.
  You may redistribute copies of GNU Emacs
  under the terms of the GNU General Public License.
  For more information about these matters, see the file named COPYING.
#+end_src

** 設定について

- [[https://github.com/takeokunn/.emacs.d][takeokunn/.emacs.d]]
- [[https://emacs.takeokunn.org/][init.el]]
- [[https://emacs.takeokunn.org/early-init][early-init]]

2022年現在、 ~init.el~ と ~early-init.el~ は6800行(空白を除くと5800行)程度あります。
設定を別ファイルに切り分けたりしておらず、 ~init.el~ 1つで管理をしています。

全ての設定を ~org-mode~ で管理しており、GitHub ActionsでbuildをしGitHub Pagesにhostingしています。

~el-get~ で導入しているpackage数は384個です。

#+begin_src shell
  $ ls -l ~/.emacs.d/el-get | wc -l
       384
#+end_src

* 起動速度の測り方
** そもそも起動速度とはなんなのか

Emacsはざっくり以下のような起動プロセスを踏みます。

- boot処理(C言語)
- [[https://github.com/emacs-mirror/emacs/blob/master/lisp/startup.el][lisp/startup.el]] が読み込まれる
- [[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L577-L850][normal-top-level]] が実行される
- [[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1125-L1639][command-line]] が実行される
- =~/.emacs.d/early-init.el= が読み込まれる
  - [[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1358-L1367][https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1358-L1367]]
- =~/.emacs.d/init.el= が読み込まれる
  - [[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1482-L1507][https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1482-L1507]]

Emacs自体にpatchを当てない限り、 =~/.emacs.d/early-init.el= より前には手が出せません。
[[https://github.com/emacs-mirror/emacs/blob/master/lisp/proced.el][lisp/proced.el]] のような既存のEmacs Lispファイルは[[https://www.emacswiki.org/emacs/DumpingEmacs][portable dumper]]で既に実行可能なbinaryに出力されており、fileをloadすることなく実行されているようです。

Emacsのbuild時に自分の ~init.el~ を読み込ませて ~pdump~ を生成するのが真の最速であり、5ms以内での起動を期待できます。
たとえ記述がほぼ無いとしても ~init.el~ と ~early-init.el~ を読み込み実行するというのは重いもので、File IOというのは重いものだと実感させられました。
しかし、それではEmacsのカスタマイズ性というのを殺すことになるので今回は含めないこととします。

** 計測方法

~init.el~ に以下のようなコードを記述します。

#+begin_src emacs-lisp
  (defconst my/before-load-init-time (current-time))

  ;;;###autoload
  (defun my/load-init-time ()
    "Loading time of user init files including time for `after-init-hook'."
    (let ((time1 (float-time
                  (time-subtract after-init-time my/before-load-init-time)))
          (time2 (float-time
                  (time-subtract (current-time) my/before-load-init-time))))
      (message (concat "Loading init files: %.0f [msec], "
                       "of which %.f [msec] for `after-init-hook'.")
               (* 1000 time1) (* 1000 (- time2 time1)))))
  (add-hook 'after-init-hook #'my/load-init-time t)

  (defvar my/tick-previous-time my/before-load-init-time)

  ;;;###autoload
  (defun my/tick-init-time (msg)
    "Tick boot sequence at loading MSG."
    (when my/loading-profile-p
      (let ((ctime (current-time)))
        (message "---- %5.2f[ms] %s"
                 (* 1000 (float-time
                          (time-subtract ctime my/tick-previous-time)))
                 msg)
        (setq my/tick-previous-time ctime))))

  (defun my/emacs-init-time ()
    "Emacs booting time in msec."
    (interactive)
    (message "Emacs booting time: %.0f [msec] = `emacs-init-time'."
             (* 1000
                (float-time (time-subtract
                             after-init-time
                             before-init-time)))))

  (add-hook 'after-init-hook #'my/emacs-init-time)
#+end_src

参考記事はこちら。

- [[https://memo.sugyan.com/entry/20120120/1327037494][起動時間を計測する 改訂版 - すぎゃーんメモ]]
- [[https://github.com/takaxp/emacs.d/blob/master/init.org#241-emacs-%E8%B5%B7%E5%8B%95%E6%99%82%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E9%A0%86][init.org - takaxp/emacs.d]]

そうすると起動後 ~*Minibuffer*~ に起動時間の出力がされるはずです。

#+begin_example
  Emacs booting time: 20 [msec] = ‘emacs-init-time’.
  Loading init files: 10 [msec], of which 1 [msec] for ‘after-init-hook’.
#+end_example

** 評価の仕方

高速化する上で重要なのは、評価指標をマシンスペックに依存しない形で評価をすることでしょう。

以下のような ~init.el~ を作成すれば、起動時にどのような処理が行われているのか知ることができます。

~init.el~:

#+begin_src emacs-lisp
  (require 'profiler)
  (profiler-start 'cpu)

  ;;; --------- 処理中略 ---------

  (profiler-report)
  (profiler-stop)
#+end_src

上記のような、処理が空の ~init.el~ を用意して起動すると以下のようなreport bufferが起動するでしょう。

#+begin_example
  Samples    %   Function
        7 100% - normal-top-level
        7 100%  - command-line
        7 100%   - startup--load-user-init-file
        7 100%    - load
        7 100%       byte-code
        0   0% + ...
#+end_example

多少ブレがあるものの、自分の ~init.el~ で実行をするとSamples数が15以内で起動します。
Sample数が素に近ければ近いほど、高速に動いていると言えるでしょう。

* この記事で達成する目標

皆さんのEmacsの起動速度はどうでしょうか？
私の感覚になりますが、大体以下のように分類できるでしょう。

- 5000ms以上
  - だいぶ遅い
  - 外部への通信(packageの更新等)が多数走ってしまっている可能性が高い
- 1000ms 〜 5000ms
  - 一般的な速度
  - 大体のEmacsユーザはこの辺だろう
  - ~use-package~ などのpackage managerを普通に使って普通に設定してるとこのくらい
- 100ms 〜 1000ms
  - ~use-pacakge~ などのpackage managerで高速化をすると大体この辺になる
  - そこそこ頑張る必要がある
- 100ms以下
  - 全ての設定をpackage managerを使わずに素で書いているか、高速化に拘った設定をしている
  - かなり頑張る必要がある
  - ~EDITOR=emacs~ 設定するのを視野に入れられる

[[https://qiita.com/delphinus/items/fb905e452b2de72f1a0f#3-%E3%81%93%E3%81%AE%E8%A8%98%E4%BA%8B%E3%81%A7%E9%81%94%E6%88%90%E3%81%99%E3%82%8B%E7%9B%AE%E6%A8%99][NeoVimの場合]]はこちら。
NeoVimでは「50ms以下」から「500ms以上」を話題にしているので明かにEmacsはスタート地点が遅い。

この記事では当然100ms以下を目指している。

* 具体的なアプローチ方法
** NativeComp
*** EmacsをFull NativeCompでBuildする

多くの人はpackage managerで落してBuildしたEmacsを使っていることでしょう。
それだと細かいbuildの設定もできないし、痒い所に手が届きません。

まずは ~git clone~ をします。

#+begin_src shell
  $ git clone git://git.sv.gnu.org/emacs.git
  $ cd emacs
#+end_src

次にNative Compでbuildします。
私は毎日 ~git pull~ した上で以下のコマンドを叩いてbuildしています。

#+begin_src shell
  $ ./autogen.sh && ./configure --with-native-compilation=aot --without-ns --without-x --with-libxml2=/usr/bin/xml2-config && make -j8
  $ sudo make install
#+end_src

~--with-native-compilation=aot~ が特に重要です。

[[https://blog.tomoya.dev/posts/hello-native-comp-emacs/][ネイティブコンパイルEmacsの登場]]に書いてありますが、2021年4月頃にNative Compがサポートされました。
~foo.el~ というファイルから ~foo.eln~ という拡張子のファイルを生成します。
~brew install libgccjit~ などをしてちゃんと ~libgccjit~ をinstallする必要があります。
[[https://www.grugrut.net/posts/202104272222/][EmacsのNative Compilationの性能を測定する]]でも検証されているが、かなりの高速化が期待できます。

[[https://github.com/emacs-mirror/emacs/commit/e245c4f226979ccb717cccc8f82b2b0a0f96bdac][Add --with-native-compilation=aot configuration option]] で ~aot~ を指定してbuildするとEmacsのFull Native Compが実行されるようになりました。
~make -j <proc>~ でproc数を多くすると処理が重すぎてPCが固まるので少なめに設定しておく方が良いです。

*** NativeCompした結果のファイル(eln)が優先的に読み込まれる

Emacs Lispで別のファイルを呼び込む際に ~(load "</path/to/dir/file>")~ のように書きます。

実際に、[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1125-L1639][command-line]]から ~init.el~ や ~early-init.el~ を読み込む時にも ~load~ は使われています。

[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/startup.el#L1011-L1120][コード(startup--load-user-init-file)]]はここです。

[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/src/lread.c#L1173-L1628][load関数の定義]] を見てみると、優先的に ~.eln~ を読むようになっているようなので早めにNative Compする必要があります。

*** init.elとearly-init.elをbyte-compileする

Byte Compileの[[https://ayatakesi.github.io/emacs/24.5/elisp_html/Byte-Compilation.html][ドキュメント]]には以下のような記述がある。

#+begin_quote
Emacs Lispには、Lispで記述された関数を、より効率的に実行できるバイトコード(byte-code)と呼ばれる特別な表現に翻訳するコンパイラー(compiler)があります。コンパイラーはLispの関数定義をバイトコードに置き換えます。バイトコード関数が呼び出されたとき、その定義はバイトコードインタープリター(byte-code interpreter)により評価されます。
#+end_quote

こんな感じでbyte-compileすると良い。

#+begin_src shell
  $ emacs -Q --batch -f batch-byte-compile early-init.el
  $ emacs -Q --batch -f batch-byte-compile init.el
#+end_src

基本的にはnative compが優先的に読まれるので意味がないと言われたらそうなのだが、後述する ~el-get~ はbyte-compile時に発火させるので流す必要があります。

*** NativeCompの設定

~native-comp-speed~ と ~native-comp-async-jobs-number~ を設定すると良いです。

~native-comp-speed~ は最適化オプションで0〜3があります。
[[https://github.com/emacs-mirror/emacs/blob/6a390fd42ec4ef97d637899fc93f34ea65639e3c/lisp/emacs-lisp/comp.el#L46-L58][ソースコード]]はこちら。
「Warning: with 3, the compiler is free to perform dangerous optimizations.」と書いてありますが、半年以上この設定で問題なく使えているので気にしなくて良いでしょう。

~native-comp-async-jobs-number~ はjob数で大きめに設定するとPCが極端に重くなってしまうので低めに設定しておくと良いでしょう。

#+begin_src emacs-lisp
  (with-eval-after-load 'comp
    (setq native-comp-async-jobs-number 8)
    (setq native-comp-speed 3))
#+end_src

*** init.elとearly-init.elをNativeCompする

~native-compile-async~ でNativeCompileできます。
コンパイル結果の出力は ~*Async-native-compile-log*~ bufferです。

#+begin_src emacs-lisp
  (native-compile-async "~/.emacs.d/init.el")
  (native-compile-async "~/.emacs.d/early-init.el")
#+end_src
** early-init.elについて
*** TODO 活用方法

書く。

** Compile時処理
*** TODO el-get-bundleをeval-when-compile時に落とす

書く。

*** TODO 環境ごとのif文をmacroで定義する

書く。

** ライブラリ周りの読み込み
*** TODO async loadをする

書く。

*** TODO autoload-if-foundを活用する

書く。

*** TODO with-eval-after-loadを活用する

書く。

** 設定
*** TODO message を一時的に無効にする

書く。

*** TODO Magic File Name を一時的に無効にする

書く。

*** TODO GCの設定

書く。

* その他
** TODO add-to-listについて

書く。

** TODO Portable Dumplerについて

[[https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4/viewer/e27557c39fceefe6c4f6#%E3%83%9D%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB%E3%83%80%E3%83%B3%E3%83%91%E3%83%BC][ポータブルダンパー - Emacs の起動時間を""詰める""]] について。

** TODO init.elの中身を別ファイルに分割して最低限の処理のみにする

書く。

* おわりに

2022年はEmacsとひたすら向きあった1年でした。
今後10〜15年耐えられる設定とはなんなのかを考えた結果の1つに「起動時間の高速化」というのがありました。
0から設定を見直し、より高速かつメンテナンス性の高い記述方法はなんなのか、 ~emacs.d~ はどうあるべきか、より善く生きていくためにはどうすれば良いのかを考えつくしました。

Emacs起動時間を高速化するにあたって、Emacs本体のソースコードを読む機会が増えて多くの知識を得ることができました。
是非皆さんも自分の設定をあらためて見直すきっかけにしていただけると幸いです。

いつもTwitterで疑問に答えてくれるEmacs Hackerの皆さんのお陰でこの記事を書くことができました。
今後ともよろしくお願いします。
