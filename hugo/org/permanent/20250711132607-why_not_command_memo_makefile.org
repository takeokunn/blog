:PROPERTIES:
:ID:       8B14E280-55E1-8184-D40B-4D60156D6646
:END:
#+TITLE: Makefileを便利コマンドメモとして使うことに対する違和感
#+AUTHOR: takeokunn
#+DESCRIPTION: description
#+DATE: 2025-07-11T16:41:09+0900
#+HUGO_BASE_DIR: ../../
#+HUGO_SECTION: posts/permanent
#+HUGO_CATEGORIES: permanent
#+HUGO_TAGS: permanent Makefile
#+HUGO_DRAFT: false
#+STARTUP: fold
* Introduction

yasunoriがZennに書いた「[[https://zenn.dev/loglass/articles/0016-make-makefile][職場のプロジェクトに必ず配置しちゃうMakefileの話]]」というのがバズっています。
「コマンドが覚え辛い」という、どのプロジェクトにもあるような問題を「Makefileをコマンドメモとして整える」ことによって解決するという記事でした。
SNSやvim-jp slackを見ていると賛同の声が多い印象を受けています。

私個人も過去に同様のMakefileを作ったことがあるし、現職でもMakefileが入っているプロジェクトがあるくらいにはよくある手法です。

しかし、この記事を読んだ時に自分としてはこの手法がイマイチだと感じました。
モヤモヤをちゃんと言語化した方がいいだろうということでこの記事を書いています。

決して元記事を批判するつもりはなく、こういう視点もあるよというくらいの温度感で捉えてほしいです。

#+begin_export html
  <blockquote class="twitter-tweet"><p lang="ja" dir="ltr">Makefileをコマンドメモに使うな</p>&mdash; たけてぃ𓁈𓈷 (@takeokunn) <a href="https://twitter.com/takeokunn/status/1247911308646699019?ref_src=twsrc%5Etfw">April 8, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
#+end_export

* Makefileをプロジェクトに入れたい時の前提整理

そもそも「誰のために」「どのプロジェクト規模で」「どういう問題を解決したくて」Makefileをプロジェクトに追加するものなのか整理する必要があります。

今回のユースケースでは、古き良きC言語をBuildする時の =make && make install= のようなタスクランナー的な使い方ではなく、元記事と同様プロジェクトのコマンドメモとしての使い方について言及しています。

** Makefileの想定利用者

想定利用者のペルソナ像は主に4種類います。

- デザインや文言を修正したい非エンジニア寄りのデザイナー
  - 役割: UI/UXデザイナー、またはマークアップ担当者
  - 技術スキル: 低〜中。HTML/CSSは触れるが、Node.jsやRubyなどのビルド環境は疎い
  - 目的: 文言・デザインの軽微修正を手元で確認し、FigmaやXDではなく「実際の画面」で見たい
  - 行動特性: できればGUIが望ましく、ターミナル操作も最低限なら頑張れる。何度も構築や手順を覚えるのは非効率と感じる
  - 主な課題: 環境構築に時間がかかる、依存が多すぎて躓く、Node/Ruby/Pythonの違いがわからない

- そのプロジェクトに精通していないプログラマ
  - 役割: 外部協力者、派遣・業務委託メンバー、新人エンジニア
  - 技術スキル: 中〜高。プログラミングスキルはあるが、そのプロジェクト特有の構成やツールには疎い
  - 目的: 限られた期間・範囲で、与えられたチケットの実装や修正を行う。全体把握は必要最低限で済ませたい
  - 行動特性: ローカル環境の立ち上げに時間を使いたくない。新規のコマンドが多すぎると混乱する
  - 主な課題: .envの場所どこ？、起動順序が分からない、バックエンドも動かさないといけないの？ などといった疑問が湧く

- そのプロジェクトに精通しているプログラマ
  - 役割: リードエンジニア、メンテナー、主要開発者
  - 技術スキル: 高。プロジェクト構成、依存ツール、インフラまで把握している
  - 目的: 長期的な保守、拡張、新機能実装、大規模な構成変更などを行う
  - 行動特性: 再利用性や抽象化に関心があり、開発フローの自動化や最適化に積極的
  - 主な課題: コマンドの乱立、属人化、ドキュメントなどが陳腐化しがち

- AI Coding Agent
  - 役割: Vibe Coding
  - 実行スキル: 正確で高速。ただし人間のような文脈解釈や柔軟なエラーハンドリングはできない
  - 目的: 指定された手順を正確に実行し、成果物のビルド・テスト・チェックを行う
  - 行動特性: 曖昧さに弱い。中間ステップが明示されていないと失敗する。STDOUTの構造化出力が必要な場合もある
  - 主な課題: コマンド実行に失敗しても、詳細な文脈を読み解いてリトライや推測はできない

** 想定しているプロジェクト規模

当記事で想定しているプロジェクトは主に3種類あります。

- 小規模プロジェクト
  - 数ページ程度のちょっとしたWebアプリケーション
  - 単一言語で書かれていて、依存しているツールチェインが少ない
  - 1万行程度
- 中規模プロジェクト
  - 複数機能があるWebアプリケーション
  - 複数言語で書かれていて、依存しているツールチェインや開発用コマンドがそれなりに多い
  - 10万行程度
- 大規模プロジェクト
  - 大規模なWebアプリケーション
  - 複数言語で書かれていて、依存しているツールチェインや開発用コマンドが多い
  - 100万程度

** Makefileで実行するコマンド

今まで見てきたコマンドは主に3種類です。

- マシン環境に依存するコマンド
  - e.g. =brew install= 、 =npm install -g= 、 =docker compose up=
- プロジェクト環境に依存するコマンド
  - e.g. =npm install= 、 =composer install=
- プロジェクト開発時に使うコマンド
  - e.g. =vendor/bin/phpstan= 、 =./gradlew build=

* 元記事の状況整理

元記事から次のような前提があるという認識を持っています。

- 想定利用者
  - そのプロジェクトに精通していないプログラマ
- Makefileで実行するコマンド
  - マシン環境に依存するコマンド
  - プロジェクト環境に依存するコマンド
  - プロジェクト開発時に使うコマンド
- 想定しているプロジェクト規模
  - 中規模プロジェクト
  - 大規模プロジェクト

次の一文からも分かるように実際の利用者の職場の人は満足しているようです。

#+begin_quote
こういう改善をやると開発チームのSlackチャンネルでは、「これはアプノマ(Update Normal)だ！」と言ってもらえる素敵な環境です。
#+end_quote
* 個人的な見解

まず大前提として、「実際の利用者が満足している」状態をどう作るかというのがもっとも重要であり、Makefileを入れることによって職場の人が満足しているのであればそれでいいし、素晴しいことだと思っています。

その上で、環境構築オタクとして「そもそもMakefileを作るのはイマイチである」と思っている点をひとつずつ整理していきました。
元記事の内容だけでなく、自分が過去に関わったプロジェクトのMakefileについても書いているのでそのあたりもご了承ください。

** 本来はREADMEを充実させるべき

規模や人にかかわらずすべてのユースケースでもっとも重要なことでここにもっとも力を入れるべきです。
何のミドルウェアに依存していて、何をどう実行するかを明文化してMarkdownで伝えることができます。

チーム全体での技術的共通認識が形成され、ブラックボックス化を防げるので属人化防止に役立ちます。
長期保守性・引き継ぎのしやすさが飛躍的に上がるのもいいですね。

Makefileに寄せてしまうとMakefileは文書に向いていないのでそもそもイマイチだし、READMEとMakefileで二重管理になるのもイマイチです。
特に元記事ではコマンドを =@echo= で出力しているので素直にREADMEに書けば良さそうに感じています。

** 「デザインや文言を修正したい非エンジニア寄りのデザイナー」に向けてならしょうがなく作る

Terminalに不慣れな人向けに =make up= で =docker compose up --build= が動くようにすることは時々あります。

そもそも =docker compose up --build= などの複雑な文字入力をさせるのは困難な場合があるので、そういう時はしぶしぶMakefileを作って =make up= だけ叩いてくださいというのが早くて正確なのでしょうがなく作っています。
そういう人向けには可能な限りTargetを減らして最低限で提供したい所です。

** 「そのプロジェクトに精通しているプログラマ」はそもそもMakefileを使わない

大体の「そのプロジェクトに精通しているプログラマ」は自分の意図したコマンドを意識して細かく実行するので、変に抽象化されたMakefileは逆に足枷になりがちな印象があります。
Makefileのメンテナンスがおざなりになり、ちゃんと動くことを保証されなくなりがちです。

これはREADMEでも起こりがちな問題ですがREADMEを充実させる方が筋がよいだろう、というのが自分の意見です。

** 「マシン環境に依存するコマンド」をMakefileで実行することに対して違和感がある

次のようなコマンドをイメージしています。

#+begin_src makefile
  install-tools: ## 開発ツールのインストール
  	brew install postgresql redis minio awscli
  	npm install -g @aws-amplify/cli
#+end_src

この手のMakefileを見るたびに次のようなことを考えています。

- そもそもREADMEを充実させる方がよい
- ワンショットで実行するものをいちいち載せたくない
- マシンに依存するコマンドはプロジェクト固有のツールではない認識なので違和感を感じる
- MiddlewareはDockerに寄せたい

** Targetが多すぎる

複雑なコマンドの組み合わせを定義したいという動機は理解できるが、それが大量に存在している時点でプロジェクト構造やワークフロー自体に根本的な歪みがある可能性が高いように感じています。
「人が覚えきれないからMakefileに記述させる」というより、「本来、そんなに複雑であるべきではなかった設計をMakefileで補っているだけ」になっている危険性がありそうな印象です。

** package固有script機能に寄せたい

npm scriptやcomposer scriptのように、現代のpackage managerにはscript機能が大体搭載されています。

ざっと次のようなメリットがあります。

- 標準化されたスクリプト管理
  - すでに存在する package.json / composer.json に統合できる
- 依存ツールとの連携がスムーズ
  - e.g.eslint, vitest, phpunit, phpstan
- エコシステムとの親和性が高い
- ドキュメントにせずとも npm run / composer run で一覧が見られる
  - シェル補完が効く
- AIや新人でも認識しやすい

「小規模プロジェクト」ならpackage固有script機能に寄せられるはずです。

オレオレMakefileを書くと「大規模プロジェクト」のような多言語用のscriptを統合できるというメリットもあるが、基本的にはREADMEに書くだけでいいはずです。
必要に応じて、package固有scriptの組み合わせMakefileを作るのはいいでしょうし、そうなるとMakefileのTargetが最低限になるはずです。

** 正規表現はメンテナンス性が低い

Shell ScriptやAWKや正規表現は「書くのは速いが、読むのは苦痛」なものです。
最初からチームや将来の自分のために、npm/composerなどの構造化されたタスクランナーの標準に乗っかっておいた方が長期的にはずっと健全だと思っています。

** AI Coding Agentフレンドリーじゃない

AI Coding Agentは構文解析と文脈理解に基づいてコードの提案・修正・生成していますが、これらのエージェントは主に構造化された明示的記法とツールチェインの規約・ドキュメントに依存します。
Makefileは伝統的なビルド定義ファイルであるが、DSLであり文脈が不透明になりやすく、推論には全体の文脈とMakefile知識が必要になります。

AIにとって解析しやすく、意図の推論や補完しやすい方がVibe Coding時代には合理的という認識です。

* その他
** org-modeで管理すればよいのでは?

「READMEを充実させる」というのが一番大事だと思っているので、READMEからコマンドを実行できること自体は理想だと思っています。
とはいえ、全員が全員Emacsを使っている訳ではないし、任意の環境で安全に実行できるのが理想なのでそこはorg-modeに寄せる必要はないですね。

** Shell Scriptにした方がよいのでは?

前述のとおり、Shell Scirptは「書くのは速いが、読むのは苦痛」なものです。
しかも、テストも書きにくいのでメンテナンス性に難が有ります。

複雑なことをしないなら尚更READMEに書いておいた方がいいし、複雑なことをするならShell Scirptではなくフレームワークのコマンド作成や別の言語に寄せたいという感覚です。

* まとめ

「本来はREADMEを充実させるべき」というのがAIにとっても新規開発者にとっても嬉しい施策だという理解です。
可能な限りREADMEなどのドキュメントをちゃんとメンテナンスしていきたいですね。
