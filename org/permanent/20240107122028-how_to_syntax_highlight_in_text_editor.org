:PROPERTIES:
:ID:       3249F27E-9CE1-4ADC-9B34-607C7DCEC60D
:END:
#+TITLE: テキストエディタがPHPをシンタックスハイライトする仕組みとモダンテキストエディタ事情について
#+AUTHOR: takeokunn
#+DESCRIPTION: description
#+DATE: 2024-01-07T12:20:39+0900
#+HUGO_BASE_DIR: ../../
#+HUGO_CATEGORIES: permanent
#+HUGO_SECTION: posts/permanent
#+HUGO_TAGS: fleeting
#+HUGO_DRAFT: true
#+STARTUP: content
#+STARTUP: nohideblocks
* 注意

この記事はPHPerKaigi 2024のパンフレット記事です。
書面での掲載につきハイパーリンクがないことをご了承ください。

https://fortee.jp/phperkaigi-2024/proposal/161b2ec9-c279-4336-8e17-1aa054dacae9

* Introduction

プログラミング言語は日進月歩で進化し続けています。
処理系のパフォーマンス改善、既存のバグ修正、挙動の変更などさまざまな変更が入るが、ユーザーにとって一番影響があるのは「新規の構文追加」ではないでしょうか？
PHPの場合PHP 8.0以降にmatch式やenum構文は直近5年以内に追加されたものです。
PHPに限らずほか言語のRFCでも新規の構文が提案されている例は枚挙に暇がありません。Goのジェネリクスなどもその一例です。

言語レベルで新規の構文が追加された時、テキストエディタでも正しく解釈できるように対応する必要があります。
それはオープンソースのテキストエディタだろうと商用エディタだろうと区別はありません。
そもそもテキストエディタはどのように構文を解釈してハイライトしてくれているのか、tree-sitterなどの最近のテキストエディタ事情も踏まえて解説していきます。

なお私は熱狂的なEmacsユーザーでありEmacsのPHP Pluginであるphp-modeのオーナー権限もあるので、Emacsひいきな解説になってしまうのはご了承ください。

* シンタックスハイライト概要

シンタックスハイライトとは、 =public= のようなキーワードや関数名や言語特有の構文に色をつけてくれるものです。
Wikipediaによると、シンタックスカラリングや構文着色とも言うらしいです。

シンタックスハイライトには、「テキストの可読性を向上させ文脈をより明瞭にする」や「記述ミスや括弧の対応のミスなどを防ぐことができる」等、さまざまなメリットがあります。
明確なデメリットは私は思いつきませんが、「流し読みがしやすくなるのでプログラマーはコード全体を理解しようとはしなくなる」ということを主張する人もいるようです。

配色はカラーテーマごとに違います。
世の中には無数のカラーテーマがあり、私はDraculaやSublime Textのdefault themeのmonokaiが好きです。

構文が違うので当然言語の数だけシンタックスハイライトがあります。
それぞれの実装によって方針はまちまちですが、似ている言語から上書きするよう実装することで実装コストを下げる対応をしています。
PHPはCやJavaと記述が似ているので、CやJavaの実装を上書きして部分的にPHPの構文を追加することで対応することもできます。
実際EmacsのPHP Pluginではこのような対応をしています。

* シンタックスハイライトの大まかなしくみ

世の中にはテキストエディタの実装は無数にあります。
プログラミング言語に対応したテキストエディタの実装はおおよそ2つに大別できます。

- 正規表現ベース
- ASTベース

正規表現ベースのシンタックスハイライトはVimやEmacsのような古くからあるテキストエディタでよく使われています。
当然それぞれのテキストエディタごとに実装は違うので移植性はありません。

ASTベースのシンタックスハイライト実装は2024年1月現在Tree-Sitterが一強だと言っても過言ではありません。
Tree-SitterはC/Rust製のツールで、特定のテキストエディタに依存しない形で実装された高速で動作するパーサジェネレータツールです。
Tree-sitterはもともとAtomで使用するためにGitHubによって開発され、2018年にはじめてリリースされました。
ソースコードをパースして構文木をs式を出力することにより、各テキストエディタはs式を解釈する実装をすれば各々が構文を解釈する必要がない、という作りになっています。

テキストエディタにおけるシンタックスハイライトの難しいところは以下が挙げられます。

- 常にユーザーが入力し続けるので構文が確定しない
- 1入力ごとにハイライトする必要がある為高速で挙動させる必要がある

また、1言語で複数言語を表現する場合難易度が上がります。
たとえばVueJSはHTML/CSS/JavaScriptを1ファイル内で記述できるし、PHPももともとHyperText PreprocessorなのでHTMLを記述できます。

* 正規表現によるシンタックスハイライト

正規表現によるシンタックスハイライトを採用しているVimやEmacsでは以下のような実装がされています。

- キーワードは直接色を付ける
- 正規表現によって構文を定義する
  - =$= の後は確実に変数
  - =function= の後は確実に関数名になり、その後の括弧は関数の引数になる
  - =//= 直後はすべてコメントになる

Emacsではシンタックステーブルというものがデフォルトで用意されており、独自の記法で記述する必要があります。

以下は実際にphp-modeで実装されているコードを抜粋したものです。
EmacsLispの正規表現がそもそも難しいのもあり、複雑怪奇で特殊な訓練しないと読めないことが分かるでしょう。

#+begin_src emacs-lisp
  ;; Class modifiers (abstract, final)
  ("\\_<\\(abstract\\|final\\)\\_>\\s-+\\_<class\\>" 1 'php-class-modifier)

  ;; Highlight variables, e.g. 'var' in '$var' and '$obj->var', but
  ;; not in $obj->var()
  ("\\(->\\)\\(\\sw+\\)\\s-*(" (1 'php-object-op) (2 'php-method-call))
  ("\\<\\(const\\)\\s-+\\(\\_<.+?\\_>\\)" (1 'php-keyword) (2 'php-constant-assign))

  ;; Logical operator (!)
  ("\\(!\\)[^=]" 1 'php-logical-op)

  ;; Highlight special variables
  ("\\(\\$\\)\\(this\\)\\>" (1 'php-$this-sigil) (2 'php-$this))
  ("\\(\\$+\\)\\(\\sw+\\)" (1 'php-variable-sigil) (2 'php-variable-name))
  ("\\(->\\)\\([a-zA-Z0-9_]+\\)" (1 'php-object-op) (2 'php-property-name))

  ;; Highlight function/method names
  ("\\<function\\s-+&?\\(\\(?:\\sw\\|\\s_\\)+\\)\\s-*(" 1 'php-function-name)

  ;; 'array' and 'callable' are keywords, except in the following situations:
  ;; - when used as a type hint
  ;; - when used as a return type
  ("\\b\\(array\\|callable\\)\\s-+&?\\$" 1 font-lock-type-face)
  (")\\s-*:\\s-*\\??\\(array\\|callable\\)\\b" 1 font-lock-type-face)

  ;; For 'array', there is an additional situation:
  ;; - when used as cast, so that (int) and (array) look the same
  ("(\\(array\\))" 1 font-lock-type-face)

  ; Support the ::class constant in PHP5.6
  ("\\sw+\\(::\\)\\(class\\)\\b" (1 'php-paamayim-nekudotayim) (2 'php-magical-constant))
  ;; Class declaration keywords (class, trait, interface)
  ("\\_<\\(class\\|trait\\|interface\\)\\_>" . 'php-class-declaration)
#+end_src

- 1言語内に複数言語の場合
  - Emacsの場合はカーソル位置の対象の言語に切り替える処理をしている
- メリット
  - 低メモリで高速で動く
    - 1990年代のPCでも動く
  - 構文を確定しなくてもハイライトできる
- デメリット
  - 正規表現の難易度が高い
  - 正規表現エンジンの実装依存になる
    - Emacsの場合は正規表現の先読みが使えない
    - しょうがないからカーソルを擬似的に動かすことによって先読みを実現している
  - 各テキストエディタごとに実装する必要がある
    - PHPのような比較的シンプルな構文の言語はまだ良い
    - C++のような複雑怪奇な構文をハイライトするには正規表現では厳しい
      - EmacsのCっぽい構文をハイライトするcc-modeは明らかに天才が作ったが凡人の我々には到底理解できない実装になっている
    - 世の中にプログラミング言語は増えているのにEmacsのようなユーザー数が減っているエディタはすべての言語に対応するのは厳しい
      - PHPに関しては私やtadsanが対応しているので我々の目が黒いうちは対応していくつもり

* ASTベースによるシンタックスハイライト

- Tree-Sitterが一強なのでTree-Sitterを元に書く
- Tree-SitterはRust/Cで書かれていて特定のエディタに依存しない実装になっている
  - LSPやDAPと似ている
- それぞれの言語ごとにgrammarが提供されている
  - phpの場合はtree-sitter-php
- 各エディタはTree-SitterのC部分のwrapperを作りエディタ内で使えるようにしている
- キーワードは直接色を付ける
- 構文はJavaScriptベースの独自DSLで記述している
  - yaccのような記述
  - https://github.com/tree-sitter/tree-sitter-php/blob/マスタ/common/define-grammar.js
- ソースコードを渡すとs式を掃き出す
- 構文エラーの場合の処理がはっきりしている
  - 構文の優先準備を記述できる
  - エラーになった箇所のみエラーという判定になる
- 1言語内に複数言語の場合
  - 特定のくくり内は =tree-sitter-{lang}= を実行するようなしくみ
- メリット
  - メジャーな言語はだいたいサポートされている
  - エディタごとの実装をする必要ないのでメンテナンスされる可能性が高い
- デメリット
  - 構文が確定するまで色がつかない
  - 毎回ASTを作る必要があるので正規表現と比べて低速
    - とはいえTree-Sitterは高速で動くし、2024年の標準的なコンピュータでは気にならない程度
  - テキストエディタ本体はTree-Sitterのサポートをし続けないといけない
    - 普通のユーザーが触れない部分なので何かあった時に対応しつらい

* 終わりに

- 言語の進化にエディタも追従する必要がある
- テキストエディタのことが好きなので頑張ってメンテナンスしてきたい
