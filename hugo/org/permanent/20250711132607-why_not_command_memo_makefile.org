:PROPERTIES:
:ID:       8B14E280-55E1-8184-D40B-4D60156D6646
:END:
#+TITLE: Makefileを便利コマンドメモとして使うことに対する違和感
#+AUTHOR: takeokunn
#+DESCRIPTION: description
#+DATE: 2022-12-22T09:00:00+09:00
#+HUGO_BASE_DIR: ../../
#+HUGO_SECTION: posts/permanent
#+HUGO_CATEGORIES: permanent
#+HUGO_TAGS: permanent Makefile
#+HUGO_DRAFT: false
#+STARTUP: fold
* Introduction

yasunoriがZennに書いた「[[https://zenn.dev/loglass/articles/0016-make-makefile][職場のプロジェクトに必ず配置しちゃうMakefileの話]]」というのがバズっている。
「コマンドが覚え辛い」という、どのプロジェクトにもあるような問題を「Makefileをコマンドメモとして整える」ことによって解決するという記事だった。
SNSやvim-jp slackを見ていると賛同の声が多い印象を受けている。

私個人も過去に同様のMakefileを作ったことがあるし、現職でもMakefileが入っているプロジェクトがあるくらいにはよくある手法である。
しかし、自分としてはこの手法がイマイチだと感じているので、ちゃんと言語化した方がいいだろうということでこの記事を書いている。

#+begin_src html
  <blockquote class="twitter-tweet"><p lang="ja" dir="ltr">Makefileをコマンドメモに使うな</p>&mdash; たけてぃ𓁈𓈷 (@takeokunn) <a href="https://twitter.com/takeokunn/status/1247911308646699019?ref_src=twsrc%5Etfw">April 8, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
#+end_src

決して元記事を批判するつもりはなく、こういう視点もあるよというくらいの温度感で捉えてほしい。

* Makefileをプロジェクトに入れたい時の前提整理

そもそも「誰のために」「どのプロジェクト規模で」「どういう問題を解決したくて」Makefileをプロジェクトに追加するものなのか整理する必要がある。

今回のユースケースは古き良きC言語をBuildする時の =make && make install= のようなタスクランナー的な使い方ではなく、元記事と同様、プロジェクトのコマンドメモとしての使い方について言及している。

** Makefileの想定利用者

想定利用者のペルソナ像は主に4種類いる。

- デザインや文言を修正したい非エンジニア寄りのデザイナー
  - 役割: UI/UXデザイナー、またはマークアップ担当者
  - 技術スキル: 低〜中。HTML/CSSは触れるが、Node.jsやRubyなどのビルド環境は疎い
  - 目的: 文言・デザインの軽微修正を手元で確認し、FigmaやXDではなく「実際の画面」で見たい
  - 行動特性: できればGUIが望ましく、ターミナル操作も最低限なら頑張れる。何度も構築や手順を覚えるのは非効率と感じる
  - 主な課題: 環境構築に時間がかかる、依存が多すぎて躓く、Node/Ruby/Pythonの違いがわからない

- そのプロジェクトに精通していないプログラマ
  - 役割: 外部協力者、派遣・業務委託メンバー、新人エンジニア
  - 技術スキル: 中〜高。プログラミングスキルはあるが、そのプロジェクト特有の構成やツールには疎い
  - 目的: 限られた期間・範囲で、与えられたチケットの実装や修正を行う。全体把握は必要最低限で済ませたい
  - 行動特性: ローカル環境の立ち上げに時間を使いたくない。新規のコマンドが多すぎると混乱する
  - 主な課題: .envの場所どこ？、起動順序が分からない、バックエンドも動かさないといけないの？ などといった疑問が湧く

- そのプロジェクトに精通しているプログラマ
  - 役割: リードエンジニア、メンテナー、主要開発者
  - 技術スキル: 高。プロジェクト構成、依存ツール、インフラまで把握している
  - 目的: 長期的な保守、拡張、新機能実装、大規模な構成変更などを行う
  - 行動特性: 再利用性や抽象化に関心があり、開発フローの自動化や最適化に積極的
  - 主な課題: コマンドの乱立、属人化、ドキュメントなどが陳腐化しがち

- AI Coding Agent
  - 役割: Vibe Coding
  - 実行スキル: 正確で高速。ただし人間のような文脈解釈や柔軟なエラーハンドリングはできない
  - 目的: 指定された手順を正確に実行し、成果物のビルド・テスト・チェックを行う
  - 行動特性: 曖昧さに弱い。中間ステップが明示されていないと失敗する。STDOUTの構造化出力が必要な場合もある
  - 主な課題: コマンド実行に失敗しても、詳細な文脈を読み解いてリトライや推測はできない

** 想定しているプロジェクト規模

当記事で想定しているプロジェクトは主に3種類。

- 小規模プロジェクト
  - 数ページ程度のちょっとしたWebアプリケーション
  - 単一言語で書かれていて、依存しているツールチェインが少ない
  - 1万行程度
- 中規模プロジェクト
  - 複数機能があるWebアプリケーション
  - 複数言語で書かれていて、依存しているツールチェインや開発用コマンドがそれなりに多い
  - 10万行程度
- 大規模プロジェクト
  - 大規模なWebアプリケーション
  - 複数言語で書かれていて、依存しているツールチェインや開発用コマンドが多い
  - 100万程度

** Makefileで実行するコマンド

今まで見てきたコマンドは主に3種類。

- マシン環境に依存するコマンド
  - e.g. =brew install= 、 =npm install -g= 、 =docker compose up=
- プロジェクト環境に依存するコマンド
  - e.g. =npm install= 、 =composer install=
- プロジェクト開発時に使うコマンド
  - e.g. =vendor/bin/phpstan= 、 =./gradlew build=

* 元記事の状況整理

元記事から次のような前提があるという認識を持っている。

- 想定利用者
  - そのプロジェクトに精通していないプログラマ
- Makefileで実行するコマンド
  - マシン環境に依存するコマンド
  - プロジェクト環境に依存するコマンド
  - プロジェクト開発時に使うコマンド
- 想定しているプロジェクト規模
  - 中規模プロジェクト
  - 大規模プロジェクト

次の一文からも分かるように実際の利用者の職場の人は満足しているようだ。

#+begin_quote
こういう改善をやると開発チームのSlackチャンネルでは、「これはアプノマ(Update Normal)だ！」と言ってもらえる素敵な環境です。
#+end_quote
* 個人的な見解

まず大前提として、「実際の利用者が満足している」状態をどう作るかというのがもっとも重要であり、Makefileを入れることによって職場の人が満足しているのであればそれでいいし、素晴しいことだと思っている。

その上で、環境構築オタクとして「そもそもMakefileを作るのはイマイチである」と思っている点を整理していく。
元記事の内容だけでなく、自分が過去に関わったプロジェクトのMakefileについても書いている。

** 本来はREADMEを充実させるべき

規模や人にかかわらずすべてのユースケースでもっとも重要なことでここにもっとも力を入れるべき。
何のミドルウェアに依存していて、何をどう実行するかを明文化してMarkdownで伝えることができる。

チーム全体での技術的共通認識が形成され、ブラックボックス化を防げるので属人化防止に役立つ。
長期保守性・引き継ぎのしやすさが飛躍的に上がるのもよい。

Makefileに寄せてしまうと、READMEとMakefileで二重管理になってしまうのでメンテナンスコストが上がる。
特に元記事ではコマンドを =@echo= で出力しているので素直にREADMEに書けば良さそうに感じている。

** 「デザインや文言を修正したい非エンジニア寄りのデザイナー」に向けてならしょうがなく作る

Terminalに不慣れな人向けに =make up= で =docker compose up --build= が動くようにすることは時々ある。

そもそも =docker compose up --build= などの複雑な文字入力をさせるのは困難な場合があるので、そういう時はしぶしぶMakefileを作って =make up= だけ叩いてくださいというのが早くて正確である。
そういう人向けには可能な限りtargetを減らして最低限で提供したい。

** 「マシン環境に依存するコマンド」をMakefileで実行することに対して違和感がある

次のようなコマンドをイメージしている。

#+begin_src makefile
  install-tools: ## 開発ツールのインストール
  	brew install postgresql redis minio awscli
  	npm install -g @aws-amplify/cli
#+end_src

この手のMakefileを見るたびに次のようなことを考えている。

- そもそもREADMEを充実させる方がよい
- ワンショットで実行するものをいちいち載せたくない
- マシンに依存するコマンドはプロジェクト固有のツールではない認識なので違和感を感じる
- MiddlewareはDockerに寄せたい

** Targetが多すぎる

複雑なコマンドの組み合わせを定義したいという動機は理解できるが、それが大量に存在している時点でプロジェクト構造やワークフロー自体に根本的な歪みがある可能性が高いように感じる。
「人が覚えきれないからMakefileに記述させる」というより、「本来、そんなに複雑であるべきではなかった設計をMakefileで補っているだけ」になっている危険性がありそうだなと感じている。

** package固有script機能に寄せたい

npm scriptやcomposer scriptのように、現代のpackage managerにはscript機能が大体搭載されている。
ざっと次のようなメリットがある。

- 標準化されたスクリプト管理
  - すでに存在する package.json / composer.json に統合できる
- 依存ツールとの連携がスムーズ
  - e.g.eslint, vitest, phpunit, phpstan
- エコシステムとの親和性が高い
- ドキュメントにせずとも npm run / composer run で一覧が見られる
  - シェル補完が効く
- AIや新人でも認識しやすい

「小規模プロジェクト」ならpackage固有script機能に寄せられるはず。

オレオレMakefileを書くと「大規模プロジェクト」のような多言語用のscriptを統合できるというメリットもあるが、基本的にはREADMEに書くだけでよい。
必要に応じて、package固有scriptの組み合わせMakefileを作るのはよいし、そうなるとMakefileのTargetが最低限になるはず。

** 正規表現はメンテナンス性が低い

Shell ScriptやAWKや正規表現は「書くのは速いが、読むのは苦痛」なものです。
最初からチームや将来の自分のために、npm/composerなどの構造化されたタスクランナーの標準に乗っかっておいた方が長期的にはずっと健全だと思っている。

** AI Coding Agentフレンドリーじゃない

AI Coding Agentは構文解析と文脈理解に基づいてコードの提案・修正・生成を行うが、これらのエージェントは主に構造化された明示的記法と、ツールチェインの規約・ドキュメントに依存する。
Makefileは伝統的なビルド定義ファイルであるが、ドメイン固有言語（DSL）であり文脈が不透明になりやすく、推論には全体の文脈とMakefile知識が必要になる。

AIにとって解析しやすく、意図の推論や補完を行いやすい方がVibe Coding時代には合理的という認識。

* その他
** org-modeで管理すればよいのでは?

「READMEを充実させる」というのが一番大事だと思っているので、READMEからコマンドを実行できること自体は理想だと思っている。
とはいえ、全員が全員Emacsを使っている訳ではないし、任意の環境で安全に実行できるのが理想なのでそこはorg-modeに寄せる必要はないと思っている。

** Shell Scriptにした方がよいのでは?

前述のとおり、Shell Scirptは「書くのは速いが、読むのは苦痛」なものである。
しかも、テストも書きにくいのでメンテナンス性に難有りという認識。
複雑なことをしないなら尚更READMEに書いておいた方がいいし、複雑なことをするならShell Scirptではなくフレームワークのコマンド作成や別の言語に寄せたいという感覚。

* まとめ

「本来はREADMEを充実させるべき」というのがAIにとっても新規開発者にとっても嬉しい施策だという理解。
可能な限りREADMEなどのドキュメントをちゃんとメンテナンスしていきたい。
